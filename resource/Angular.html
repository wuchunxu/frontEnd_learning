<h2>Angular</h2>
<button class="back">返回</button>
<ul class="menu">
    <li>
        <p>软件的设计原则和模式</p>
        <div class="desc">
            <h2>软件的设计原则和模式</h2>
            <h3>设计原则</h3>
            <h4>简单原则</h4>
            <h4>避免重复原则</h4>
            <h4>单一责任原则</h4>
            <h4>开闭原则</h4>
            <p>(1)对扩展开放，对修改关闭</p>
            <p>(2)可变性不应该散落在代码的各个角落，而应该被封装到一个对象中</p>
            <p>(3)一种可变性不应当与另外一种可变性混合在一起</p>
            <h4>高聚合低耦合原则(High Cohesion & Low Coupling)</h4>
            <p>内聚：度量一个类独立王城某项工作的能力</p>
            <p>耦合：度量系统内或系统之间依赖关系的复杂度</p>
            <h4>迪米特法则(Law of Demeter)</h4>
            <p>一个对象或者模块应该尽可能减少与其他对象或模块之间的通信</p>
            <h3>软件的设计模式</h3>
            <p>不同的应用场景中，对象和类之间有不同的交互方式，这就是设计模式。设计模式是被人们反复使用、代码经验的总结。</p>
            <p>设计模式有：工厂模式、抽象工厂模式、建造者模式、原型模式、单例模式、适配器模式、桥接模式、组合模式、装饰模式、门面模式、享元模式、代理模式、责任链模式、命令模式、解析器模式、迭代器模式、中介模式、备忘录模式、观察者模式、状态模式、策略模式、模板模式、访问者模式、MVC模式</p>
            <h4>MVC模式</h4>
            <p>MVC模式，即模型-视图-控制器模式。<strong>减少视图与具体数据的耦合，使得多个视图可以访问相同的数据。</strong></p>

        </div>
    </li>
    <li>
        <p>了解Angular</p>
        <div class="desc">
            <h2>Angular</h2>
            <h3>背景</h3>
            <p>AngularJS诞生于2009年，是一个用于开发单页面应用程序(SPA)的JS框架，易于构建页面的CRUD操作。</p>
            <p>基本操作思路与DOM及jQuery的“先查找元素再操作元素”不同，它是“创建数据、绑定数据、修改数据和更新数据”，一切操作以数据为中心。</p>
            <h3>七大核心概念</h3>
            <p><strong>(1)模块、(2)指令、(3)组件、(4)模板、(5)数据绑定、(6)服务、(7)依赖注入</strong></p>
            <h4>模块</h4>
            <pre class="code">@ngModule({
    declaration:[],
    imports:[],
    providers:[]
})</pre>
            <h4>组件</h4>
            <p>封装的html</p>
            <h4>模板</h4>
            <p>组件中，扩展了HTML语法</p>
            <h4>装饰器</h4>
            <p>将导入的类，装饰成指定功能</p>
            <h4>指令</h4>
            <pre class="code">@Directive(selector:"[test]");</pre>
            <h4>管子</h4>
            <p>过滤器</p>
            <pre class="code">@Pipe({name:"myUpperCase"})</pre>
            <h4>服务</h4>
            <p>用来封装常用的业务逻辑，也就是说，组件中不应该存在大量的业务逻辑，如果有，应该封装到服务中。</p>
            <h3>工作原理</h3>
            <p>使用Angular扩展语法编写HTML模板，用<em>组件类</em>管理这些模板，用<em>服务</em>添加应用逻辑，用<em>模块</em>打包发布组件和服务。然后，我们通过<em>引导根模块</em>来启动该应用。</p>
            <p>Angular在浏览器中接管、展现应用的内容，并根据我们提供的操作指令响应用户的交互。</p>
            <h3>TypeScript</h3>
            <p>TypeScript的设计目标是开发大型应用，然后转译成JavaScript。</p>
            <h3>安装</h3>
            <h4>angular-cli</h4>
            <pre class="code">npm install -g @angular/cli
ng new my-app
cd my-app
ng serve --open</pre>
            <h4>quick start安装</h4>
            <p>解压quickstart-master.zip，然后将node_modules拷贝到quickstart文件夹并解压。</p>
            <pre class="code">npm start</pre>
            <h3>Angular启动流程</h3>
            <pre class="code"><span class="note">npm start:
        --> npm build --> src/index.html
        --> src/main.ts -->./src/app/app.module.ts
        --> ./src/app/app.components.ts</span>
            </pre>
            <h3>目录结构</h3>
            <pre class="code"><span class="note">
src  工程目录
 > main.ts     入口文件
 > app         模块(组件)目录
    > app.module.ts   根模块
            </span></pre>
            <h3>Angular架构</h3>
            <div class="img"><img src="images/angular_frame.png" alt=""/></div>
        </div>
    </li>
    <li>
        <p>TypeScript</p>
        <div class="desc">

        </div>
    </li>
    <li>
        <p>模块(Module)</p>
        <div class="desc">
            <h2>模块</h2>
            <h3>模块是什么</h3>
            <blockquote>模块是组件之上的一层抽象。</blockquote>
            <p>一个应用有且只有一个<span class="code">根模块(Root Module)</span>，其他模块叫<span class="code">特性模块(Feature Module)</span>，根模块是应用的入口，根模块中通过bootstrap元数据来指定应用的根组件。</p>
            <h3>模块中元数据</h3>
            <pre class="code">@ngModule({
    declaration:[],<span class="note">//指定该模块中有哪些视图类</span>
    imports:[],<span class="note">//引入该模块依赖的其他模块或路由</span>
    exports:[],<span class="note">//导出视图类，其他模块可以导入使用这些视图类</span>
    providers:[] <span class="note">//指定模块依赖的服务</span>
})</pre>
            <p>Angular中视图类包括：组件（Component）、指令（Directive）和管道（Pipe）。注意：视图类只能属于一个模块，如果想要在另外一个模块中使用，应该用“先导出，再导入”的方式。</p>
            <p>指令是需要声明或导入才可以使用的。事实上，默认指令时通过 <span class="code">BrowserModule</span>引入的。</p>
        </div>
    </li>
    <li>
        <p>组件(Component)</p>
        <div class="desc">
            <h2>组件(Component)</h2>
            <p>题外话，W3C为了统一组件化的标准方式，提出了Web Component标准。当前支持最好的是Chrome和Opera浏览器。Web Component以后可能会流行，这里，我们暂时先不考虑它。</p>
            <h3>了解组件</h3>
            <blockquote>Angular中的组件是<strong>自描述</strong>的：1)可以和宿主元素交互；2)知道如何、何时渲染自己；3)可配置注入服务；4)有明确的Input和Output定义。</blockquote>
            <p>组件和模块的关系</p>
            <h3>创建组件</h3>
            <pre class="code">
<span class="note">//demo.component.ts</span>
import {Component} from '@angular/core'<span class="note">//导入组件类</span>
<span class="note">//装饰器将Component类装饰成一个组件</span>
@Component({
    selector: 'demo01',<span class="note">//这里是元数据</span>
    template:`&lt;h2>Demo component&lt;/h2>`
})
<span class="note">//导出组件类</span>
export class Demo01Component{}</pre>
            <h3>声明组件</h3>
            <p>创建好的组件，要在模块中声明之后才可以使用。</p>
            <pre class="code">import { NgModule }  from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AppComponent }  from './app.component';
<span class="note">import { Demo01Component } from './demo01/demo01.component'</span>

@NgModule({
  imports:      [ BrowserModule ],
  declarations: [ AppComponent,<span class="note">Demo01Component</span> ],
  bootstrap:    [ AppComponent ]
})
export class AppModule { }</pre>
        <h3>组件之间的通信(交互)</h3>
        <p>组件之间的通信有多种方式，<strong>非父子关系的组件可以通过服务来实现数据的交互。</strong></p>
        <h4>父子组件之间的通信</h4>
        <h5>父传子</h5>
        <p>父组件通过子组件的输入属性(@Input装饰过的属性)将数据传递给子组件，子组件接收数据还可以进行拦截处理(“访问器属性”)。</p>
        </div>
    </li>
    <li>
        <p>指令</p>
        <div class="desc">
            <h2>指令</h2>
            <h3>指令</h3>
            <h4>循环指令(<span class="code">*ngFor</span>)</h4>
            <pre class="code">`&lt;ul>
    &lt;li <span class="note">*ngFor="let ele of list;let i = index"</span>>[{{i+1}}]{{ele}}&lt;/li>
&lt;/ul>`</pre>
            <h4>选择指令(<span class="code">*ngIf</span>)</h4>
            <pre class="code">&lt;ng-container *ngFor="let ele of books;let i=index">
    &lt;tr <span class="note">*ngIf="ele.price>50"</span>>
        &lt;td>{{i+1}}&lt;/td>
        &lt;td>{{ele.name}}&lt;/td>
        &lt;td>{{ele.author}}&lt;/td>
        &lt;td>{{ele.price}}&lt;/td>
    &lt;/tr>
&lt;/ng-container></pre>
            <p>注意：一个标签内只能放一个指令，如果需要放置多个指令，把多余的放到ng-container标签中</p>
            <h4>多重分支</h4>
            <pre class="code">&lt;ul <span class="note">[ngSwitch]="str"</span>>
    &lt;li <span class="note">*ngSwitchCase="'a'"</span>>A&lt;/li>
    &lt;li <span class="note">*ngSwitchCase="'b'"</span>>B&lt;/li>
    &lt;li <span class="note">*ngSwitchCase="'c'"</span>>C&lt;/li>
&lt;/ul></pre>
            <h4>属性绑定(<span class="code">[myProp]</span>)</h4>
            <pre class="code">&lt;a <span class="note">[href]="myLink"</span>>点我&lt;/a></pre>
            <h4>style和class属性绑定(<span class="code">[ngStyle]、[ngClass]</span>)</h4>
            <pre class="code">&lt;p [ngStyle]="{'opacity'=my_opacity}">{{city}}&lt;/p>
&lt;p [ngClass]="{'red'=true}">{{city}}&lt;/p></pre>
            <h4>事件绑定(<span class="code">(click)</span>)</h4>
            <pre class="code">&lt;button <span class="note">(click)="handleClick()"</span>>点我&lt;/button></pre>
            <h4>双向数据绑定</h4>
            <p>双向数据绑定需要导入表单模块<span class="code">FormsModule</span></p>
            <pre class="code">import {FormsModule} from '@angular/forms';
@ngModule({
    imports:[FormsModule]
})
export class Demo05Component {
    constructor(){}
    city:string = "";
    handleChange(){ console.log(this.city);}
}
//demo05.component.html
&lt;input <span class="note">[(ngModel)]="city" (ngModelChange)="handleChange"</span>>
&lt;p>{{city}}&lt;/p></pre>
            <h3>自定义指令</h3>
            <p>自定义指定，首先导入angular核心包中的<span class="code">Directive</span>类，然后用装饰器将该类装饰成指令，并导出指令类。</p>
            <pre class="code">import { <span class="note">Directive,ElementRef</span> } from '@angular/core'
@Directive({
    selector:"<span class="note">[test]</span>"
})
export class TestDirective{
    constructor(<span class="note">private eleRef: ElementRef</span>){
        console.log("test指令被调用");
        console.log(this.eleRef.nativeElement);
        <span class="note">this.eleRef.nativeElement.style.background= "green";</span>
    }
}</pre>
        </div>
    </li>
    <li>
        <p>管子pipe(过滤器)</p>
        <div class="desc">
            <h2>pipe</h2>
            <h3>angular提供的管子</h3>
            <h4>字符串管子</h4>
            <pre class="code">{{uname | <span class="note">lowercase</span>}}
{{uname | <span class="note">uppercase</span>}}
<span class="note">//字符串切割</span>
{{uname | <span class="note">slice:3:6}}</span></pre>
            <h4>日期管子</h4>
            <p>angular中，管子传参用 <span class="code">:</span>表示</p>
            <pre class="code">{{nowDate | date}}
{{nowDate | <span class="note">date:'yyyy-MM-dd hh:mm:ss'</span>}}</pre>
            <h3>自定义管子</h3>
            <p>快捷键<span class="code">a-p</span>，创建好pipe后，同样需要在根模块中声明</p>
            <pre class="code">import { Pipe, PipeTransform } from '@angular/core';
@Pipe({
    name: 'myuppercase'
})
export class Demo10Pipe implements PipeTransform {
    transform(value: any, ...args: any[]): any {
        if(args[0]){
            return value.toUpperCase();
        }else{
            return value.toLowerCase();
        }
    }
}</pre>
        </div>
    </li>
    <li>
        <p>服务</p>
        <div class="desc">
            <h2>Service</h2>
            <h3>了解服务</h3>
            <h4>为什么要用服务？</h4>
            <p>在Angular中，组件最好只负责UI相关的逻辑，如果组件中参杂大量的<em>业务代码</em>或<em>数据处理逻辑</em>，会导致组件代码量过大，不便于维护。这时，应该将业务代码和数据处理逻辑封装到服务中。</p>
            <h4>何时使用服务？</h4>
            <table>
                <tr>
                    <td>1</td>
                    <td>多个组件中重复的代码提取到服务中，从而实现代码的复用。</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>业务代码和数据处理逻辑应该封装到服务中，有利于后期更新和维护。</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>多个组件中注入同一个服务实例可以实现数据的共享。</td>
                </tr>
            </table>
            <h4>常见的服务</h4>
            <table>
                <tr>
                    <td>数据服务</td>
                    <td>负责与服务器通信（数据）</td>
                </tr>
                <tr>
                    <td>验证服务</td>
                    <td>检查用户的服务（功能）</td>
                </tr>
                <tr>
                    <td>日志服务</td>
                    <td>跟踪错误（功能）</td>
                </tr>
            </table>
            <h3>使用服务</h3>
            <p>假设我现在需要完成一个通讯录编辑联系人的功能，那么我需要1)从服务器获取联系人信息；2)验证用户修改的数据；3)提交修改的数据到服务器。</p>
            <h4>创建服务</h4>
            <pre class="code">import { Injectable } from '@angular/core'; <span class="note">//导包</span>
@Injectable() <span class="note">//装饰成可注入</span>
export class ContactService{
    <span class="note">//获取联系人数据</span>
    getContactsData(){}
    <span class="note">//更新联系人数据</span>
    updateContacts(contact:Contact){}
}</pre>
            <h4>使用服务</h4>
            <pre class="code">import { ContactService } from '...';
export class SomeComponent{
    constructor(private contactService:ContactService){}
}</pre>
            <h3>HTTP服务</h3>
            <pre class="code"><span class="note">//(1)在根模块中导入HttpModule</span>
//app.module.ts
import { HttpModule } from '@angular/http';
@NgModule({
    imports:[HttpModule]
})
<span class="note">//(2)使用组件中导入服务类并声明引入</span>
import { Http } from '@angular/http';

export class ContactComponent{
    constructor(http:Http){}
}</pre>
            <h3>封装一个完整的http请求服务</h3>
            <pre class="code"><span class="note">//首先在根模块中导入HttpModule</span>
import {Injectable } from '@angular/core';
import { Http,Response } from '@angular/http';
import { Obeservable } from 'rxjs/Rx';

const URL = '';
@Injectable()
export class ContactService {
    constructor( private http: Http){}

    getContacts(): Obeservable&lt;any[]>{
        return this.http.get(URL)
                .map((res:Response)=>res.json().data || {}))
                .catch(this.handleError);
    }
}
</pre>
            <h3>创建http请求服务</h3>
            <p>使用vscode，快捷键</p>
            <pre class="code"><span class="note">//a-service-http</span>
    sendRequest(url:string){
        <span class="note">//a-http-get</span>
        return this.http.get().map((req:Request)=>{req.json()})
    }
            </pre>
            <h3>注册服务</h3>
            <p>服务创建好之后，需要在根模块中导入，并添加到服务供应商中</p>
            <h3>组件中注入服务</h3>
            <p>在需要使用服务的组件中，导入服务类，在构造器中注入该服务类的实例(依赖注入)</p>
            <h3>带证书的get请求</h3>
            <p>如果请求的url带有session数据，添加证书</p>
            <pre class="code">this.http.get(url,{widthCredentials:true});</pre>
            <p>在php中，设置跨域，不能为*</p>
            <pre class="code">header("Access-Control-Allow-Origin:localhost:3000");
header("Access-Control-Allow-Credentials:true");</pre>
        </div>
    </li>
    <li>
        <p>组件之间的通信</p>
        <div class="desc">
            <h2>组件之间的通信</h2>
            <h3>父传子</h3>
            <p>父组件在子组件标签中绑定属性</p>
            <pre class="code">
import {Input} from '@angular/core';
@Input() msg:string="";//表示msg是接收过来的</pre>
            <h3>子→父</h3>
            <pre class="code"><span class="note">//父组件</span>
import {Input} from '@angular/core';
...
&lt;son (childToParent)="handleMsg($event)">&lt;/son>
<span class="note">//子组件</span>
import {Output,EventEmitter} from '@angular/core';
...
@Output() childToParent = new EventEmitter();<span class="note">//声明一个output，为EventEmitter对象</span>
private sendMsg():void{
    this.childToParent.emit();
}</pre>
        </div>
    </li>
    <li>
        <p>路由(Router)</p>
        <div class="desc">
            <h2>路由</h2>
            <h3>创建和配置路由模块</h3>
            <h4>创建路由模块(app/app.router.ts)</h4>
            <pre class="code"><span class="note">/*
    快捷键a-module-routing，生成一个路由模块的模板
    导入需要的类
*/</span>
import { NgModule } from '@angular/core';
import { RouterModule,Routes } from '@angular/router';
import {CartComponent,...} from ...<span class="note">//导入组件</span>
<span class="note">//配置路由对象</span>
const routes:Routes = [
    {path:"cart",component:CartComponent},
    {path:"pay",component:PayComponent},
    {path:"",redirectTo:"pay"},
    {path:"**",component:FileNotFoundComponent}<span class="note">//404</span>
];
@NgModule({
    imports:[RouterModule.forRoot(routes)],
    exports:[RouterModule]
})
export class AppRoutingModule{}</pre>
            <h4>将路由模块导入根模块</h4>
            <pre class="code">import { AppRoutingModule } from './app.router';
@NgModule({
    imports:[ AppRoutingModule ]
})</pre>
            <h4>路由显示区(路由出口)</h4>
            <pre class="code">&lt;router-outlet>&lt;/router-outlet></pre>
            <p>配置好之后，改变url就可以实现组件跳转了。每次要手动改路径显然不够灵活、人性化。我们需要使用其他的跳转方法。</p>
            <h3>更多的路由跳转方法</h3>
            <h4>路由链接</h4>
            <pre class="code">&lt;a <span class="note">routerLink="/cart"</span>>购物车&lt;/a>
<span class="note">//如果是动态的，则用属性绑定，表达式传参</span>
&lt;a <span class="note">[routerLink]="'/checkout/'+price"</span>>去结算&lt;/a>
</pre>
            <h4>js控制路由跳转</h4>
            <pre class="code">import { Router } from '@angular/router';
this.router.navigateByUrl('/cart');</pre>
            <h4>前进和后退</h4>
            <p>点击事件绑定方法，组件构造器中注入Location实例location</p>
            <pre class="code">this.location.back();
this.location.forward();</pre>
            <h3>路由的传参</h3>
            <pre class="code"><span class="note">//配置路由</span>
{path:'detail/:uid'}
<span class="note">//在接收的组件中</span>
import { ActivatedRoute } from '@angular/router'
constructor( private ar:ActivatedRoute ){}
ngOnInit(){
    this.ar.params.subscribe(result=>{
        console.log(result);
    });
}
&lt;a routerLink="/detail/1">&lt;/a></pre>
            <h3>子路由</h3>
            <pre class="code">const routes:Routes = [
    {
        path:"mail",
        component:MailComponent,
        children:[
            {path:"",redirectTo:"inbox"},
            {path:"inbox",component:InboxComponent},
            {path:"outbox",component:OutboxComponent}
        ]}
];</pre>
            <p>url中：<span class="code">/mail/inbox</span>进行子路由的切换，注意这里与Vue的区别。</p>
            <h3>路由守卫</h3>
            <p>作用是拦截对某个组件的直接访问。</p>
            <h4>创建一个守卫服务(sendGuard.service.ts)</h4>
            <pre class="code"><span class="note">//快捷键：a-guard-can-activate</span>
return false;//表示禁止直接访问
return true;//允许直接访问</pre>
            <h4>在路由模块中给指定路径添加守卫</h4>
            <pre class="code">{path:"manager",component:ManagerComponent,<span class="note">canActivated:[sendGuard]</span>}</pre>

        </div>
    </li>
</ul>