<h2>函数(Function)</h2>
<ul class="menu">
	<li>
		<p>垃圾回收</p>
		<div class="desc">
			<h2>垃圾回收(Garbage Collection)</h2>
			<table>
				<tr><td>什么是垃圾</td><td>一个不再被任何变量使用的对象</td></tr>
				<tr>
					<td>什么是垃圾回收</td>
					<td>js引擎会自动回收不再被使用的对象的空间。</td>
				</tr>
				<tr>
					<td>什么是垃圾回收器</td>
					<td>专门负责回收垃圾对象的小程序——js引擎自带</td>
				</tr>
				<tr>
					<td>工作机制</td>
					<td>
						<ol>
							<li>1. 程序执行时，垃圾回收器伴随主程序执行而执行。</li>
							<li>2. 每创建一个对象，垃圾回收器就会记录对象被几个变量引用着.</li>
							<li>3. 如果发现一个对象不再被任何变量应用，则自动回收该对象的存储空间。</li>
						</ol>
					</td>
				</tr>
			</table>
			<p>好的习惯：对象不再使用，将其赋值为null</p>
		</div>
	</li>
	<li>
		<p>匿名自调函数</p>
		<div class="desc">
			<h2>匿名自调函数</h2>
			<h3>了解匿名函数</h3>
			<p>匿名函数，即没有名字的函数，匿名函数调用后，由于没有引用，因此会被垃圾回收器回收，释放内存。</p>
			<h3>匿名函数的作用</h3>
			<h4>只调用一次的函数</h4>
			<h4>划分临时作用域</h4>
			<p>回调：定义函数后，自己不调用，而是传递给另一个函数去调用</p>
			<p>自调：自定义函数后，立刻调用自己。注意：所有的js代码都要放在匿名自调函数中，以避免全局污染。</p>
			<p><strong>立即执行函数(Immediately Invoked Function Expression)非常重要，可以避免全局污染。</strong></p>
		</div>
	</li>
	<li>
		<p>作用域和作用域链</p>
		<div class="desc">
			<h2>作用域和作用域链(Scope & Scope Chain)</h2>
			<h3>JS中的作用域</h3>
			<p>JS中只有2种作用域，全局作用域和函数作用域。作用域规定了变量的范围。变量的查找顺序：先找局部，如果没有，去父级作用域中找。</p>
			<h3>函数的生命周期</h3>
			<table>
				<tr><td>函数执行前</td><td>创建一个数组（执行环境栈,ECS）,用于记录正在执行的函数。由于浏览器本身也是一个程序，因此ESC中首先记录的是浏览器的主程序main()<p>main()执行时，会创建全局作用域对象（window），保存所有浏览器内置的对象和方法</p></td></tr>
				<tr><td>函数定义时</td><td>1、在全局创建函数名变量；2、</td></tr>
				<tr><td>函数执行前</td></tr>
				<tr><td>函数执行前</td></tr>
			</table>
			<p></p>
		</div>
	</li>
	<li>
		<p>闭包-Closure</p>
		<div class="desc">
			<h2>闭包-Closure</h2>
		</div>
	</li>
</ul>