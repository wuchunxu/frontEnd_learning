<h2>JavaScript内置类型</h2>
	<ul class="menu">
		<li>
			<p>String</p>
			<div class="desc">
				<h3>字符串</h3>
				<p>字符串是一个字符数组，用来存储多个字符</p>
				<h3>String类型的API</h3>
				<table>
					<tr><td>获取指定位置字符</td><td>str.charAt(i)/<strong></strong>str[i]</td></tr>
					<tr><td>获取指定位置字符的Unicode码</td><td>str.charCodeAt(i)</td></tr>
					<tr>
						<td>获取子串</td>
						<td>
							<p>slice(start[,end])</p>
							<p>substring(start[,end])</p>
						</td>
					</tr>
					<tr><td>大小写转换</td><td><p>toUpperCase()</p>toLowerCase()<p></p></td></tr>
					<tr><td>Unicode码-->汉字</td><td>String.fromCharCode(unicode)</td></tr>
				</table>
			</div>
		</li>
		<li>
			<p>数组类型-Array</p>
			<div class="desc">
				<h2>数组</h2>
				<h3>深入认识JavaScript中的数组</h3>
				<h4>数组是对象的子类型，因此数组可以像对象那样使用，比如添加属性。</h4>
				<pre class="code">var arr = ["1",2,3];
arr.name = "array";       //看，数组可以添加属性(属性式)
arr["date"] = "20180233"; //键值式
arr.length;               //但是，不改变数组的length属性，仍然是3
arr.name;                 //通过属性方式访问name，值为"array"
arr["4"] = "4";           //"4"转成4，arr[4]="4";
arr.length;               //5
arr[3];                   //undefined</pre>
				<h4>且看for..in和for..of，发现数组属性与数组元素的区别</h4>
				<p>JavaScript中，for..in循环是用来遍历对象属性的。注意：js中对象在底层是关联数组，或者叫哈希数组，说白了就是键值对。</p>
				<pre class="code">//for..in循环是用来遍历对象属性
for(var key in arr){
	console.log(key);       //0	 1	2	name
}
//for..of循环用来迭代数组中存储的元素，ES6新增
for(var ele of arr){
	console.log(ele);       //"1"	2	3
}
</pre>
			</div>
		</li>
		<li>
			<p>函数类型-Function</p>
			<div class="desc">
				<h2>函数类型</h2>
				<h3>理解Function</h3>
				<p>内存中保存一段代码段的对象</p>
				<h3>创建函数</h3>
				<table>
					<tr>
						<td>直接量</td>
						<td>function fn(arg){}</td>
					</tr>
					<tr>
						<td>表达式</td>
						<td>var fn = function(){}</td>
					</tr>
					<tr>
						<td>new</td>
						<td>var fun = new Function("arg1","arg2","函数体;return xxx;");</td>
					</tr>
				</table>
				<h3>声明提前(hoist)</h3>
				<p>hoist：将变量的声明提前，函数的声明提前</p>
				<p>函数名其实是一个普通的变量</p>
				<p></p>
				<pre class="code">console.log(a);//undefined
var a = 10;
function fun(){ console.log(1); }
fun();//2
function fun(){ console.log(2); }
fun();//2</pre>
				<h3>重载(overload)--减少API的数量</h3>
				<p>根据传入参数的不同，执行不同的操作</p>
				<p>js通过arguments对象来实现重载</p>
				arguments对象是一个类数组对象
				<pre class="code">function fn(){
	if(arguments.length==0){
		
	}else if(arguments.length==1){
		
	}else{
		
	}
}</pre>
				<p>例子：定义add()函数，可传入任意参数，求和</p>
<pre class="code">function add(){
	var result = 0;
	for(var i=0;i < arguments.length;i++){
		result += arguments[i];
	}
	return result;
}
</pre>
				<h3>笔试题</h3>
				<p>以下创建函数正确的是：</p>
				<pre class="code">function fun(a,b){return a-b}
var fun = function(a,b){return a-b;}
var fun = new Function(a,b,"return a-b");//错</pre>
				<p>参数和参数类数组对象的关系--以下输出：</p>
				<pre class="code">function fun(a,b){
console.log(arguments[0]);
a++;
console.log(arguments[0]);
arguments[0]++;
console.log(a);
}
fun(1,2);</pre>
			</div>
		</li>
		<li>
			<p>对象类型-Object</p>
			<div class="desc"></div>
		</li>
		<li>
			<p>全局对象-Global</p>
			<div class="desc"></div>
			
		</li>
		<li>
			<p>正则类型-RegExp</p>
			<div class="desc">
				<h2>正则表达式类型(RegExp)</h2>
			</div>
		</li>
		<li>
			<p>错误类型-Error</p>
			<div class="desc">
				<h2>Error类型</h2>
				<h3>了解Error</h3>
				<p>Error对象用来保存错误信息。</p>
				<p>程序发生错误会强行退出。这时错误处理就显得非常重要了。错误处理可以让程序在发生错误时而不中断运行。</p>
				<pre class="code">
try{
	//代码
}catch (error){
	alert(error.message);
}
				</pre>
				<h3>Error的问题</h3>
				<p>被动接收错误，无法精确提示用户</p>
				<p>try catch比正常程序执行效率低</p>
				<h3>解决方法</h3>
				<p>如果可以预知错误，则用if..else..来代替try..catch..</p>
				<h3>抛出自定义错误</h3>
				<p>在协作开发中，程序的作者用于提醒调用者错误的使用了你的程序，<span class="code">throw new Error("自定义错误信息");</span></p>
				<h3>笔试题</h3>
				<p>JS中有哪几种错误类型？</p>
				<table>
					<tr><th>错误</th><th></th></tr>
					<tr><td>SyntaxError</td><td>语法错误</td></tr>
					<tr><td>ReferenceError</td><td>引用错误，要用的变量未找到</td></tr>
					<tr><td>TypeError</td><td>类型错误</td></tr>
					<tr><td>RangeError</td><td>范围错误，参数超范围</td></tr>
					<tr><td>URIError</td><td></td></tr>
					<tr><td>EvalError</td><td></td></tr>
				</table>
			</div>
		</li>
		<li>
			<p>日期类型--Date</p>
			<div class="desc">
				<h2>时间类型</h2>
				<h3>Date类型</h3>
				<p>Date对象用来存储一个时间，并提供操作时间的相关API</p>
				<p><strong>关于计算机中时间的存储，有一些注意点：</strong></p>
				<ol>
					<li>计算机中以<em>当前时间距离计算机元年(1970/01/01)所经历的毫秒数</em>来存储时间。这样做的好处是，时间不受时区的影响，同时毫秒数是一个数值，方便计算。</li>
					<li>当需要显示给客户时，将毫秒数转换成年月日时分秒，再加上时差，就可以表示不同时区的当地时间了。</li>
					<li></li>
				</ol>
				<h3>创建日期对象</h3>
				<p>创建日期对象，可以向构造函数传入多种参数：<em>无参数、"yyyy/mm/dd hh:MM:ss"、时间对象、毫秒数</em></p>
				<table>
					<tr>
						<td><strong>无参数</strong></td><td><span class="code">var now = new Date();</span></td>
					</tr>
					<tr>
						<td>自定义时间</td><td><span class="code">var birthday = new Date("1993/01/01");</span></td>
					</tr>
					<tr>
						<td>复制已有时间</td><td><span class="code">var date2 = new Date(birthday);</span></td>
					</tr>
					<tr><td><strong>毫秒数</strong></td><td>var date = new Date(ms);</td></tr>
				</table>
				<h3>JS中时间的单位</h3>
				<table>
					<tr><td>FullYear</td><td>年</td><td></td></tr>
					<tr><td>Month</td><td>月</td><td>0~11</td></tr>
					<tr><td>Date</td><td>日</td><td>取值范围1~31</td></tr>
					<tr><td>Day</td><td>星期</td><td>0~6，0表示周日</td></tr>
					<tr><td>Hours</td><td>时</td><td>0~23</td></tr>
					<tr><td>Minutes</td><td>分</td><td>0~59</td></tr>
					<tr><td>Seconds</td><td>秒</td><td>0~59</td></tr>
					<tr><td>Milliseconds</td><td>毫秒</td><td></td></tr>
				</table>
				<p>获取年份：getFullYear()</p>
				<p>设置年份：setFullYear()</p>
				<p>获取当月的第几天：date.getDate()</p>
				<p>设置第几天：<span class="code">date.setDate(2)</span>,这里要特别注意<strong>日期溢出</strong>的问题，例如
<pre class="code">
var date = new Date();
date.setMonth(1);//2月份
date.setDate(32);//由于2018年2月只有28天，32-28=4，所有日期实际设置为3月4日
</pre></p>
				<h3>日期格式化</h3>
				<table>
					<tr><th>函数</th><th>功能</th></tr>
					<tr><td>.toString()</td><td>完整格式</td></tr>
					<tr><td>.toLocaleString()</td><td>转为<em>当地时间简化格式</em></td></tr>
					<tr><td>.toLocaleDateString()</td><td>当地时间简化格式，<em>只有日期</em>部分</td></tr>
					<tr><td>.toLocaleTimeString()</td><td>当地时间简化格式，<em>只有时分秒</em></td></tr>
					<tr><td>.toGMTString()</td><td>国际标准时间（0时区）</td></tr>
				</table>
				<h3>例子</h3>
				<h4>求60天后的日期</h4>
				<pre class="code">
var start = new Date();
var end = new Date(start);//创建一个副本
end.setDate(end.getDate()+60);//拿到天数，对天数进行运算，再设置</pre>
				<h4>合同日期的相关计算</h4>
				<p>到期时间：hiredate+3年</p>
				<p>续签时间：提前一个月续签，如果续签日期是周六，或周日提前到周五</p>
				<pre class="code">
var hiredate = new Date("2012/06/30");
var enddate  = new Date(hiredate);
enddate.setFullYear(enddate.getFullYear() + 3);//3年后到期
var renewDate = new Date(enddate);//创建一个到期时间的副本
renewDate.setMonth(renewDate.getMonth()-1);//提前一个月续签
var day = renewDate.getDay();
var offset = (day==0)? -2 : (day==6 ? -1 : 0);//提前的天数
renewDate.setDate(renewDate.getDate()+offset);
console.log(renewDate);</pre>
			</div>
		</li>
		<li>
			<p>Math对象--Math</p>
			<div class="desc">
				<h2>Math对象</h2>
				<h3>Math对象</h3>
				<p>Math对象封装了数学计算的常量和方法，Math对象不是类，不需要用new来创建，直接调用即可</p>
				<h3>Math对象的API</h3>
				<table>
					<tr><th colspan="3">方法</th><th>功能</th></tr>
					<tr><td rowspan="3">取整</td><td>向上取整</td><td>Math.ceil(number)</td><td></td></tr>
					<tr>
						<td rowspan="2">向下取整</td>
						<td>Math.floor(number)</td>
						<td></td>
					</tr>
					<tr>
						<td>parseInt(number)</td><td>将字符串解析成数字（整型）</td>
					</tr>
					<tr>
						<td colspan="2">四舍五入</td>
						<td>Math.round(number)</td>
						<td>注意：不能指定保留小数</td>
					</tr>
					<tr>
						<td colspan="2">乘方</td>
						<td>Math.pow(number,index)</td>
						<td>Math.pow(x,y)表示x^y，x的y次幂</td>
					</tr>
					<tr>
						<td colspan="2">开平方</td>
						<td>Math.sqrt(number)</td>
						<td>开平方</td>
					</tr>
					<tr>
						<td colspan="2">随机数</td>
						<td>Math.random()</td>
						<td>区间为[0,1)的随机数</td>
					</tr>
				</table>
				<h4>Number.prototype.toFixed(d)</h4>
				<p>可以将一个数字类型的值四舍五入为保留d位小数的数，但结果是String类型</p>
				</p>
				<h4>自定义round()</h4>
<pre class="code">
function round(number,digit){
	var offset = Math.pow(10,d);
	return Math.round(number*offset)/offset;
}
</pre>
				<h3>应用</h3>
				<h4>根据两点的坐标，求方向的度数</h4>
				<p>Math.atan2()</p>
			</div>
		</li>
		<li>
			<p>包装类型</p>
			<div class="desc">
				<h2>包装类型</h2>
				<h3>ES中的包装类型</h3>
				<p>ES中简单基本类型<em>string、number、boolean</em>有对应的包装类型<em>String、Number、Boolean。</em></p>
				<p>基本类型的值不是对象，只能保存值，没有相关的操作API。ES标准内置了包装类型，而包装类型提供了对应基本类型值相关的API，方便操作。当尝试用基本类型的值调用API时，程序会自动创建对应的包装类型对象，来帮助基本类型的值完成指定操作，操作完成后，对象会自动释放。</p>
				<pre class="code">var num = 3.14159;
num.toFixed(2);//"3.14"
/*
 	以上代码会自动装箱(auto-boxing)
	1) typeof num  --> number
	2) new Number(num).toFixed(2)-->"3.14"
	3) 自动释放Number对象
 */</pre>
				<h3>笔试题</h3>
				<h4>输出的值为多少？</h4>
				<pre class="code">var str = "hello";
str.len = 10;
console.log(str.len);//undefined</pre>
				<h4>谈谈你对包装类型的理解。</h4>
				<p>包装类型是什么？</p>
				<p>为什么使用包装类型？</p>
				<p>如何使用包装类型？</p>
			</div>
		</li>
		<li>
			<p>查找关键词</p>
			<div class="desc">
				<h3>查找一个固定关键词出现的位置--字符串的indexOf()方法</h3>
				<p>如果找到，返回关键词的第一个字符的下标位置；如果未找到，则返回-1</p>
				<pre class="code">var index = str.indexOf("keyword"[,fromIndex]);
var index = str.lastIndexOf("keyword");//反向查找</pre>
				<h3>判断是否包含某一系列关键词--正则的search()方法</h3>
				<pre class="code">var index = str.search(/Regex/);</pre>
				<p>如果找到，返回关键词的位置；如果未找到，返回-1</p>
				<p>注意：正则表达式中，默认是区分大小写的，如果两者都要匹配，则加上关键词i（意思是ignore）</p>
				<h3>需要获得关键词的内容--正则的match()方法</h3>
				<pre class="code">var str = "this is my first regex";
var arr = str.match(/regex/i);</pre>
				<p>Attention! <span class="code">match()</span>方法返回值是一个数组，<span class="code">["regex", index: 17, input: "this is my first regex"]</span>；如果没有找到返回null，如果要使用，则需要先判断是否为null！</p>
				<h3>既要找关键词的内容，亦要关键词的位置--正则的exec()</h3>
			</div>
		</li>
		<li>
			<p>附：正则表达式</p>
			<div class="desc">
				<h2>正则表达式</h2>
				<h3>什么是正则表达式</h3>
				<p>正则表达式是用来描述字符串中字符出现规则的表达式。比如<span class="code">支付宝</span>，可以匹配“支付宝”。</p>
				<p>但如果既要能匹配“支付宝”，又要匹配“微信”呢？可以<span class="code">支付宝|微信</span>，这里<span class="code">|</span>表示“或”的意思，“|”的两侧表示两个规则，满足其一即可。</p>
				<p>然而，现实中的需求往往没这么简单。比如，我要匹配微信、微 信、WX、wx、weixin、wxin呢？</p>
				<p>可以这么来：<span class="code">(微|w(ei)?)\s*(信|x(in)?)</span></p>
				<p>在上面表达式中，<span class="code">()</span>表示分组，也就是<span class="code">(ei)</span>表示一个组，它将e和i组合在一起，这样就可以用量词来修饰，<span class="code">?</span>是量词，表示匹配0次或1次。这样，意思就是匹配w或者wei；中间<span class="code">\s</span>表示匹配任意空白，<span class="code">*</span>是量词，表示匹配任意多次（0~n）</p>
				<p>上述小例子中，我们学习了<span class="code">|、()、\s、*、?</span></p>
				<table>
					<tr>
						<td>或 |</td><td>规则1|规则2</td><td>满足规则1或规则2</td>
					</tr>
					<tr>
						<td>分组 ()</td><td>(规则1规则2)</td><td>将规则1和规则2归为一组，后面可以使用量词来修饰</td>
					</tr>
					<tr>
						<td rowspan="4">字符集[]</td>
						<td>[1,2,3]</td>
						<td>1,2,3中任意一个，注意，一个[]只能匹配1个字符</td>
					</tr>
					<tr><td>[0-9]</td><td>匹配一个数字</td></tr>
					<tr><td>[a-z]</td><td>匹配一个小写字母</td></tr>
					<tr><td>[A-Za-z]</td><td>匹配一个字母</td></tr>
					<tr><td rowspan="4">预定义字符集</td><td>\d</td><td>数字，相当于[0-9]</td></tr>
					<tr><td>\w</td><td>一位数字，字母或下划线[0-9A-Za-z_]</td></tr>
					<tr><td>\s</td><td>空白</td></tr>
					<tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr>
					<tr>
						<td rowspan="7">量词</td>
						<td>?</td>
						<td>0次或1次</td>
					</tr>
					<tr><td>+</td><td>至少1次</td></tr>
					<tr><td>*</td><td>任意多次，包括0</td></tr>
					<tr><td>{3}</td><td>匹配3次</td></tr>
					<tr><td>{3,5}</td><td>匹配3~5次</td></tr>
					<tr><td>{3,}</td><td>至少3次</td></tr>
				</table>
				<h3>正则表达式的例子</h3>
				<ul>
					<li>需求一：验证身份证格式</li>
					<li>需求二：屏蔽聊天语句中的微信、WX、wx、wxin、weixin、WeChat</li>
					<li>需求三：验证邮箱格式、手机号码格式、车牌号格式</li>
				</ul>
			</div>
		</li>
	</ul>
</div>



