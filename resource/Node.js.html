<h2>Node.js</h2>
<ul class="menu">
    <li>
        <p>了解Node.js</p>
        <div class="desc">
            <h2>了解后端知识</h2>
            <h3>进程和线程</h3>
            <p>进程是操作系统分配资源的基本单位；线程是cpu调度和分配的基本单位。</p>
            <p>进程和线程的关系：进程中可以包括多个线程，线程必须依赖于进程存在；每个进程至少有一个线程，称为主线程</p>
            <h3>全局对象</h3>
            <h4>console对象</h4>
            <p>console对象负责向stdout/stderr输出信息console.log/warn/error/assert</p>
            <pre class="code">//断言 ：用在测试
console.assert(expression,'断言执行失败')
//如果expression执行结果为真，就是执行下句话，否则抛出异常,程序结束</pre>
            <h4>process对象</h4>
            <p>进程对象，当前解释器运行所在的进程对象。通过该对象，可以获取当前操作系统及运行信息，并操作脚本所在执行的进程。</p>
            <pre class="code">process.arch //获取CPU架构类型
process.platform //获取操作系统类型
process.env       //获取操作系统环境变量
process.pid      //进程编号
process.kill(123) //结束掉进程编号为123的进程
process.hrtime() //获取纳秒级别的高精准度的时间

process.cwd()     //获取当前所在工作目录
process.execPath    //获取解释器所在目录
process.execArgv    //获取解释器执行参数
process.argv        //获取解释器运行时的命令行参数
process.versions   //获取Node.js版本信息
process.uptime()    //获取Node.js解释器运行时间(s)
process.memoryUsage() //获取内存信息

process.pid        //获取进程ID号
process.kill( pid )  //向指定进程ID号发送退出信号

            </pre>
        </div>
    </li>
    <li>
        <p>核心模块</p>
        <div class="desc">
            <h2>核心模块</h2>
            <p>学习Node.js要经常查看<strong><a href="https://nodejs.org/api/">官方文档</a></strong>。</p>
            <h3>Console模块</h3>
            <p>Console模块，控制台模块，提供了一种控制台调试输出的机制。该模块向外导出了两个成员：</p>
            <table>
                <tr>
                    <td>Console class</td>
                    <td>用于向任意Node.js<em>输出流对象</em>执行输出</td>
                </tr>
                <tr>
                    <td>global.console</td>
                    <td>global.console=new Console(process.stdout,process.stderr);</td>
                </tr>
            </table>
            <h3>OS模块</h3>
            <p>OS模块提供了很多用于获得当前操作系统信息的方法。</p>
            <pre class="code">os.EOL //代表OS End-Of-Line常量
os.tmpdir()         <span class="note">//返回OS的临时目录</span>
os.hostname()       <span class="note">//返回当前主机名称</span>
os.platform()       <span class="note">//返回当前OS平台类型</span>
os.uptime()         <span class="note">//返回当前已经运行的时间，时间秒</span>
os.totalmem()       <span class="note">//返回OS总内存大小，单位字节</span>
os.freemem()        <span class="note">//返回所有CPU内核信息</span>
os.cpus()           <span class="note">//返回所有CPU内核信息</span>
os.networkInterface()<span class="note">//返回所有网络接口信息</span></pre>
            <h3>Readline模块</h3>
            <p>Readline模块提供的Interface对象，可以从标准输入对象或其他输入流对象中<em>一行一行地</em>读取数据。</p>
            <pre class="code">const readline = require("readline");
const fs = require("fs");
const os = require("os");
var rl = readline.createInterface({
    input: process.stdin,
    output:process.stdout
});
let outFile = fs.createWriteStream("./user");
rl.question("请输入用户名：",line=>{
    outFile.write(line+os.EOL);
    reader.close();
});
            </pre>
            <p>readline有事件成员，如line，每当遇到换行符就会触发该事件。如果我们需要不停的读取行数据，就可以给rl对象注册line监听</p>
            <pre class="code">rl.on("line",line=>{
    if(line!=="exit"){
        outFile.write(line+EOL);
    }else{
        rl.close();
        outFile.close();
    }
});</pre>
            <p>createInterface()可以输入很多参数</p>
            <pre class="code">const readline = require("readline");
const fs = require("fs");
const os = require("os");

let outFile = fs.createWriteStream("./copy.html");
let inFile  = fs.createReadStream("./src.html");

let rl = readline.createInterface({
    input: inFile,
    output:process.stdout,
    terminal: false
});

let counter = 0;
rl.on("line",line=>{
    console.log(++counter+" "+line+os.EOL);
    outFile.write(counter+ " " + line+os.EOL);
});</pre>
        <h3>Query String模块</h3>
        <p>Query String模块提供了处理URL中查询字符串部分的相关操作。</p>
        <pre class="code">const qs = require("querystring");
let data = {
    "uname":"丁大壮",
    "gender":"男",
    "upwd":"123456"
};

let str = qs.stringify(data);<span class="note">//将json转化成query string，这样node.js可以作为客户端发送数据</span>
let json = qs.parse(str);<span class="note">//node.js可以将query string解析成json对象，方便使用</span>

console.log(str);<span class="note">//uname=%E4%B8%81%E5%A4%A7%E5%A3%AE&gender=%E7%94%B7&upwd=123456</span>
console.log(json);<span class="note">//{ uname: '丁大壮', gender: '男', upwd: '123456' }</span></pre>
        <h3>url模块</h3>
        <p>url模块提供的parse方法可以将url解析成对象，第二个参数为true时，查询字符串也解析成对象。此外还提供resolve方法拼接基地址。</p>
        <pre class="code">const url = require("url");
let base = "http://tmooc.cn/sub/index.html";//基地址
let src = "../img/logo.png";
let result = url.resolve(base,src);
console.log(result);</pre>
        </div>
    </li>
    <li>
        <p>包</p>
        <div class="desc">
            <h3>CommonJS规范</h3>
            <p>CommonJS不是一门语言，而是为js定义的API标准和规范，从而拓宽js的应用范围。最终提供类似Python、Ruby和Java语言一样丰富的功能。</p>
            <p>Node.js实现了CommonJS规范。</p>
            <h4>CommonJS包规范</h4>
            <p>package：包，在模块的基础上更深一步抽象，类似于java的类库。它将某种独立的功能封装起来，用于发布、更新、依赖管理和版本控制。</p>
            <table>
                <tr>
                    <td>1</td>
                    <td>一个package.json文件应该存在于包顶级目录下</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>二级制文件应该包含在bin目录下</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>js代码应该包含在lib目录下</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>文档应该在doc目录下</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>单元测试应该在itest目录下</td>
                </tr>
            </table>
            <p>Node.js中require()函数可以引入文件模块外，还可以引入符合上述规范的包。</p>
            <h3>常用的第三方包</h3>
            <p>browserify、gulp、npm、grunt-li、grunt、cordva、bower、express、forever</p>
            <table>
                <tr>
                    <td>colors</td>
                    <td>命令行彩色输出</td>
                </tr>
                <tr>
                    <td>event-stream</td>
                    <td>Stream流操作工具</td>
                </tr>
                <tr>
                    <td>mocha</td>
                    <td>单元测试</td>
                </tr>
                <tr>
                    <td>mysql</td>
                    <td>连接MySQL</td>
                </tr>
                <tr>
                    <td>request</td>
                    <td>HTTP客户端</td>
                </tr>
                <tr>
                    <td>restify</td>
                    <td>REST API搭建</td>
                </tr>
                <tr>
                    <td>socket.io</td>
                    <td>WebSocket实时通信</td>
                </tr>
                <tr>
                    <td>xml2js</td>
                    <td>XML转换工具</td>
                </tr>
            </table>
        </div>
    </li>
    <li>
        <p>npm</p>
        <div class="desc">
            <h3>NPM</h3>
            <p>npm，Node Package Manager，是非官方提供的用于下载、安装、查找、更新、删除第三方Node.js包的工具，同时，还可以执行打包、发布模块，解决模块间依赖性等功能，已经成为Node.js包管理的标准。</p>
            <p>Node.js安装文件汇总，已经集成了npm包管理工具。</p>
            <h4>创建包</h4>
            <pre class="code">npm init</pre>
            <p>npm会帮助我们创建package.json</p>
            <p>npm package json</p>
            <h4>发布包</h4>
            <pre class="code">//(1)注册npm账号
//(2)npm adduser 命令登录账号
//(3)npm publish发布包</pre>
            <h4>下载包</h4>
            <pre class="code">npm install &lt;pkg>
npm install &lt;pkg>@&lt;version>
npm install &lt;pkg> --save/--save-dev
            </pre>
            <h4>本地安装和全局安装</h4>
            <p>本地安装：安装包保存在./node_module下，如果没有则创建一个</p>
            <pre class="code">npm i packageName</pre>
            <p>全局安装：安装包保存在/usr/local，可以直接在命令行里运行。</p>
            <h4>维护包</h4>
            <pre class="code">nmp ls //列出本地目录已经安装的包
npm ls -g //列出全局目录已经安装的包
nmp ls &lt;pkg> //列出包的版本信息
npm info &lt;pkg> //详细信息
npm update &lt;pkg> //更新已安装的包
npm uninstall &lt;pkg> //卸载已安装包
            </pre>
        </div>
    </li>
    <li>
        <p>事件驱动和非阻塞模型</p>
        <div class="desc">
            <h2>事件驱动和非阻塞模型</h2>
            <h3>进程和线程</h3>
            <p>进程：操作系统将可执行文件从磁盘载入内存，为其分配必需的可执行代码内存和数据内存。<strong>进程是操作系统分配内存的基本单位。</strong></p>
            <p>线程Thread：是进程内部执行代码的基本单位。一个进程内可以同时创建多个线程，并发执行多段代码。</p>
            <p>每个线程需要自己独立的数据内存空间，大小为2MB。</p>
            <h3>面试题</h3>
            <h4>进程和线程的关系</h4>
            <p>进程是操作系统分配内存的基本单位；而线程是CPU调度的基本单位。</p>
            <p>进程可以包含多个线程，而线程必须依赖于进程而存在。</p>
            <p>进程类似工厂里的车间，线程类似车间里的工人。</p>
            <h4>在一个进程中，线程越多越好吗？</h4>
            <p>多线程切换时，需要进行上下文的切换，是耗时的操作，所以并不建议同时存在很多线程。</p>
            <h3>服务器种类</h3>
            <h4>经典的单线程服务器</h4>
            <h4>多线程服务器</h4>
            <p>为同时处理多个客户端的连接请求，一般都设计为多线程运行模式，即每个客户端连接都有一个服务线程。</p>
            <p>对于CPU密集型请求可以充分利用多核CPU的优势，同时为尽可能多的客户提供服务。但是多线程模型也存在下列问题：</p>
            <p>1) 每个线程内部的操作都是线程执行的，耗时操作会阻塞后续操作；</p>
            <p>2) 受限于线程总数的限制，无法并发的处理大量的请求；</p>
            <p>3) 过多过频繁的线程上下文切换，产生了更多的CPU开销；</p>
            <p>4) 多线程并发往往伴随着互斥和死锁等问题，增加了程序设计的复杂度。</p>
            <p>其解决方法是：采用“集群”的方式。</p>
            <h4>nodeJS单线程服务器</h4>
            <p>Node.js采用了一种基于<em>“事件循环”的非阻塞式单线程模型</em>，在保证每个请求都可以快速得到响应的同时，实现了远超多线程模型的并发连接数。其特点是：</p>
            <p>1) 服务器端只有一个请求服务线程；</p>
            <p>2) 所有的请求都会在“事件循环列队”中等待；</p>
            <p>3) 请求服务线程依次为每个请求服务，但不会为任何请求而阻塞。</p>
            <h3>阻塞和非阻塞</h3>
            <table>
                <tr>
                    <td>阻塞</td>
                    <td>block、synchronize</td>
                </tr>
            </table>
            <h3>事件循环</h3>
            <h4>事件列队(Event Queue)</h4>
            <p><strong>事件触发时，处理函数并不是立即执行，而是加入事件列队。只有当主线程中代码都执行完毕，才开始执行事件列队中任务。</strong>这样会导致一些问题，例如，点击某个元素，不能立刻执行绑定的函数，其原因是：等运行的代码运行结束，可能之前还有排队的事件。</p>
            <p>事件列队的顺序：timers/iocallbacks/immediate/close event</p>
            <h4>事件循环</h4>
            <p>主线程执行完毕，就去事件列队中读取，再运行，再读取，如此循环。</p>
            <img src="images/event_loop1.png" title="event loop">
            <h3>深入理解定时器</h3>
            <p>有一个误区，"给定时器设置0ms运行一次就是尽可能频繁的运行该事件"，这句话看似很合理，但设计者并不是这样设计的。HTML规范：延时/时间颗粒度最小值为4ms。每秒大概触发200多次，而while循环每秒触发400万次/秒，Node达到500万次。--javascript异步编程</p>
            <p>如果需要更细的事件颗粒度？</p>
            <p>(1)Node.js中，process.nextTick；</p>
            <p>(2)现代浏览器(IE9+)支持requestAnimationFrame函数，该函数允许60+帧/秒的速度运行js动画</p>
            <h3>process.nextTick和setImmediate的区别</h3>
            <table>
                <tr>
                    <td>process.nextTick</td>
                    <td>
                        <p>在当前“执行栈”后插入回调函数，也就是说，总是在任务列队所有任务之前执行</p>
                        <p>不用检查“任务列队”，执行效率高</p>
                    </td>
                </tr>
                <tr>
                    <td>setImmediate</td>
                    <td><p>追加在任务列队的尾部，在下一次event loop时执行</p></td>
                </tr>
            </table>








        </div>
    </li>
</ul>