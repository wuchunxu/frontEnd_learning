<h2>React</h2>
<button class="back">返回</button>
<ul class="menu">
    <li>
        <p>函数式编程</p>
        <div class="desc">
            <h2>函数式编程</h2>
            <h3>了解函数式编程--WHAT,WHY</h3>
            <blockquote>在Javascript中，函数是第一类公民。</blockquote>
            <p>说实话，这句话不太好理解。我暂时的理解是，
                <strong>JavaScript中函数可以赋值给变量，那么函数就可以当作变量来使用了。比如，函数可以当作参数进行传递，也可以作为结果返回</strong>(说到这里，我想到了闭包，闭包形成的很自然啊)。</p>
            <p>函数式是一种编程范式，与面向对象技术不同。为什么要用函数式，可以先了解一下“命令式”和“声明式”编程方式的区别。像ES5中，Array.prototype.map、reduce函数就是函数式，它们的参数是一个回调函数，用来定义遍历数组的操作。用map与for循环的区别是，前者更关注对数组元素的具体操作，不用考虑如何遍历了。</p>
            <p>函数式将具体实现过程进行了封装。小函数联合使用可以封装成大的函数，就像“搭积木”。这一点来看，模块的封装也是类似的道理。</p>
            <h3>使用ES6语法</h3>
            <h4>使用const可以保证函数定义后不会被重写</h4>
            <pre class="code">const log = (msg)=>console.log(msg) ;</pre>
            <h3>函数式编程的基本概念</h3>
            <h4>不可变性</h4>
            <p>不可变性的工作机制是，不改变原数据，在拷贝上修改。</p>
            <pre class="code">let color_lawn = {
    title:"lawn",
    color:"#00ff00",
    rating:0
}
<span class="note">//ES5写法</span>
var rateColor = function(color,rating){
    return Object.assign({},color,{rating:rating});
}
<span class="note">//ES6写法</span>
const rateColor = <span class="note">(color,rating)=>({
    ...color,
    rating
})</span>
<span class="note">//数组</span>
const addColor = (title,list)=>[...list,{title}]</pre>
            <h3>纯函数</h3>
            <p>纯函数(1)至少接收一个参数；(2)必须返回一个值；(3)不能修改外环境和参数</p>
            <h3>数据的转换</h3>
            <p>ES5为Array新增了API，其中就有不少是“干净的”操作(不影响原数组)。</p>
            <h4>Array.prototype.filter--数组的过滤</h4>
            <p>按照以前的思路，我们可能会用for循环遍历，if判断，找到目标值并用splice()将其删除。这里，按“不可变的原则”，我们可以使用filter：</p>
            <pre class="code">const colors = ['blue','red','green','yellow'];
    const removeColor = (remove,arr)=>{
        return arr.filter(color=>color !== remove) <span class="note">//只要不是去除对象就留下</span>
    }
    console.log(removeColor('yellow',colors).join(','));
                </pre>
            <h4>Array.prototype.map</h4>
            <p>
                <strong>需求：创建纯函数，修改对象数组中的某个对象。</strong>
            </p>
            <pre class="code">let colors=[
        {name:"red"},
        {name:'green'},
        {name:'yellow'}
    ];
    <span class="note">//创建纯函数</span>
    const editColors = (oldName,name,arr)=>
        arr.map(ele=>ele.name===oldName?({...ele,name}):ele)
    
    console.log(editColors('yellow','blue',colors));</pre>
            <h4>对象转换成数组</h4>
            <pre class="code">const colors = {
    "red":"#FF3030",
    "green":"66CD00",
    "blue":"63B8FF"
};
<span class="note">//将该对象转换成数组</span>
const = colorsArray = <span class="note">Object.keys(colors)</span>.map(key=>{
    name:key,
    value:colors[key]
})</pre>
            <h4>Array.prototype.reduce</h4>
            <pre class="code"><span class="note">//利用reduce求最大值</span>
const nums = [2,1,6,22,16,5,5,10];
const max = nums.reduce(
    (max,num)=>(num>max)?num:max
,0)</pre>
            <h3>高阶函数</h3>
            <h4>WHAT</h4>
            <p>高阶函数是可以操作其他函数的函数。可以将函数当作参数传入，也可以返回一个函数，或者两着都有。</p>
            <h3>函数的合成</h3>
            <p>函数式编程通常将具体的业务逻辑拆分成小型的
                <strong>纯函数</strong>，最终再整合到一起构成应用。像jQuery中的链式调用就是合成的一种方式，不过还有更优雅的：</p>
            <pre class="code">const compose = (...fns) =>
    (arg) => fns.reduce(
        (result,fn)=>fn(result),
        arg
    )</pre>
        </div>
    </li>
    <!-- <li>
        <p>React运行机制</p>
        <div class="desc">
            <h2>React运行机制</h2>
        </div>
    </li> -->
    <li>
        <p>React日常使用</p>
        <div class="desc">
            <h2>React</h2>
            <h3>cli安装React</h3>
            <pre class="code">npm install -g create-react-app <span class="note">//安装工具</span>
create-react-app myapp <span class="note">//创建app</span></pre>
            <h3>react中使用scss</h3> 
            <h4>安装sass-loader</h4>
            <pre class="code">npm i sass-loader node-sass --save-dev</pre>
            <h4>修改webpack文件</h4>
            <p>在node_modules/react-scripts/config目录下找到webpack.config.dev.js文件，</p>
            <p>直接在node_modules中修改配置文件会导致项目移植出问题，所以需要将配置文件从node_modules中暴露出来，<span class="code">npm run eject</span></p>
            <pre class="code"><span class="note">{
    test:/\.scss$/,
    loaders:['style-loader','css-loader','sass-loader']
},</span>
            
exclude: [/\.(js|jsx|mjs)$/, /\.html$/, /\.json$/,<span class="note">/\.scss$/</span>],</pre>
            <h3>设置Proxy</h3>
            <pre class="code"><span class="note">//在package.json里添加：</span>
"proxy": {
    "/": {
        "target": "http://20.255.48.2:9003",
        "changeOrigin": true,
        "secure": false
    }
}</pre>
            <h3>兼容IE9-IE10</h3>
            <p>React自带的babel编译只是将ES6、ES7..等语法的代码转换成ES5，但是没有ES6及以后的API，所以要polyfill。</p>
            <h4>第一种：babel-polyfill</h4>
            <pre class="code">npm i babel-polyfill --save
<span class="note">//在根文件index.js最上面导入polyfill</span>
import 'babel-polyfill';
            </pre>
            <h4>【推荐】第二种：core-js</h4>
            <pre class="code">npm i core-js --save
import 'core-js/es6/map';
import 'core-js/es6/set';

<span class="note">//polyfill requestAnimationFrame</span>
npm i raf --save;
import 'raf/polyfill';</pre>
            <h4>使用antd中Layout布局，只能兼容到IE10</h4>
            <p>使用了Flex布局，仅支持到IE10，<span class="code">-ms-</span></p>
        </div>
    </li>

    
    <li>
        <p>JSX</p>
        <div class="desc">
            <h2>JSX</h2>
            <h3>JSX基础知识</h3>
            <p>JSX是JavaScript的一种扩展语法</p>
            <h4>可以嵌入表达式</h4>
            <pre class="code">const user = {
    firstname:"Wu",
    lastname:"Chunxu"
};
<span class="note">//如果JSX表达式换行，建议加上括号</span>            
const element = (<span class="note">&lt;h1>Hello,{user.firstname+user.lastname}&lt;/h1></span>);

ReactDOM.render(
    element, 
    document.getElementById('root')
);</pre>
            <p>JSX编译后变成js对象。我们可以这么理解，JSX语法只是为了简化js生成DOM元素对象，那么，我们就可以把JSX当作js对象。它可以作为参数、返回值或者赋值给某个变量。</p>
            <h4>属性中插入表达式</h4>
            <p>属性的值如果是一个变量，那么就要用到表达式，JSX语法规定，js表达式写在
                <span class="code">{}</span>内，而普通的字符串则写在引号
                <span class="code">""</span>内</p>
            <pre class="code">const element = &lt;img src=<span class="note">{user.avatarUrl}</span>>&lt;/img>;</pre>
            <h4>jsx默认防止注入攻击(XSS)</h4>
            <h4>JSX的写法偏向于JavaScript</h4>
            <p>因此，html中的属性要采用js中的驼峰写法。</p>
            <pre class="code">const element = (
    &lt;h1 <span class="note">className="greeting"</span>>Hello World&lt;/h1>
);</pre>
            <h3>元素渲染</h3>
            <p>像下面element元素，它编译后只是一个普通的对象，非常容易创建，ReactDOM负责更新DOM。</p>
            <pre class="code"><span class="note">//html文件中应该有一个根DOM节点，它的内容由ReactDOM来管理。单纯用React构建的应用只有一个根，而将React嵌入到现有的app则可能有多个根DOM节点。</span>
&lt;div id="root">&lt;/div>
        
const element = &lt;h1>Hello,world&lt;/h1>
ReactDOM.render(
    element,
    document.getElementById('root')
);</pre>
            <h4>更新已经渲染的元素</h4>
            <pre class="code">function tick(){
    const element = (
        &lt;div>
            &lt;h1>Hello,world&lt;/h1>
            &lt;h2>现在是{new Date().toLocaleTimeString()}&lt;/h2>
        &lt;/div>
    );
    ReactDOM.render(
        element, 
        document.getElementById('root')
    );
}
setInterval(tick,1000); <span class="note">//每隔1秒钟，重新渲染</span></pre>
            <p>要特别注意的是，React元素是immutable，一旦创建无法修改(包括子元素和属性)，只能重新渲染。ReactDOM会检查当前元素与之前版本的差异，只对有必要更新的DOM进行更新。</p>
            <p>Angular中也可以使用immutable特性</p>
        </div>
    </li>
    <li>
        <p>组件</p>
        <div class="desc">
            <h2>组件和属性</h2>
            <h3>组件</h3>
            <p>组件类似JavaScript中的函数，接收输入(props)，返回React元素，用以描述屏幕要显示的内容。</p>
            <dl class="accordion">
                <dt>定义组件</dt>
                <dd>
                    <p>组件是一个类，在ES6之前没有类的概念，也可以用构造函数的写法。</p>
                    <strong>函数式组件写法</strong>
                    <pre class="code">function Welcome(props){
    return &lt;h1>Hello,{props.name}&lt;/h1>
}</pre>
                    <strong>ES6类的写法</strong>
                    <pre class="code">import React,{Component} from 'react';
import ReactDOM from 'react-dom';

class Welcome extends Component{
    render(){
        return &lt;h1>Hello,{this.props.name}&lt;/h1>
    }
}</pre>
                </dd>
                <dt>使用组件</dt>
                <dd>
                    <p>在使用组件时，JSX的属性会被封装在一个对象中，如下例，会被封装到{name:"wuchunxu"},这个对象名为props</p>
                    <pre class="code">ReactDOM.render(
    &lt;div> <span class="note">//必须有根标签</span>
        &lt;Welcome name="Tom"/>,
        &lt;Welcome name="Jerry" /> <span class="note">//空标签必须闭合</span>
    &lt;/div>,
    document.getElementById("root")
);</pre>
                </dd>
            </dl>
            <h3>属性</h3>
            <p>属性就是参数，用来传递值。注意：
                <strong>组件无法修改props对象，所有的组件必须是纯函数(不能修改输入)。</strong>
            </p>
        </div>
    </li>
    <li>
        <p>属性 Props</p>
        <div class="desc">
            <h2>Props</h2>
            <h3>什么是属性？</h3>

            <h3>安全性相关</h3>
            <p>组件实质上是一个函数，它接收参数，并返回JSX元素。由于JS不是强类型语言，不能限制参数的类型和数量，使用组件，在运行时才发现出错。为了解决该问题，React提供了属性验证和默认属性。</p>
            <h4>属性验证和属性默认值</h4>
            <pre class="code"><span class="note">//类的写法</span>
class Summary extend React.Component {
    <span class="note">//属性验证器，静态的，属于类</span>
    static propTypes = {
        ingredients:Proptypes.number,
        steps: Proptypes.number,
        <span class="note">//自定义属性验证</span>
        title:(props,propName)=>
            (typeof props[propName] != 'string')?
                new Error('标题必须为字符串'):
                    props[propName].length>20 ? 
                        new Error('标题不能超过20个字符'):
                        null
    }
    <span class="note">//默认值</span>
    static defaultProps = {
        ingredients : 0,
        steps: 0,
        title : "[recipe]"
    }
}
    
<span class="note">//函数的写法</span>
const Summary = (<span class="note">{ingredients=0,steps=0,title='[recipe]'}</span>)=>
    return (...)
<span class="note">
Summary.propTypes = {

}</span>
            </pre>
            <p>默认属性如果是函数：</p>
            <pre class="code">static defaultProps = {
    <span class="note">onClick:f=>f</span> //占位符，被js调用，但没有任何动作
}</pre>
            <table>
                <tr>
                    <th>类型</th>
                    <th>验证器</th>
                </tr>
                <tr>
                    <td>数组</td>
                    <td>React.PropTypes.array</td>
                </tr>
                <tr>
                    <td>布尔类型</td>
                    <td>React.PropTypes.bool</td>
                </tr>
                <tr>
                    <td>函数</td>
                    <td>React.PropTypes.func</td>
                </tr>
                <tr>
                    <td>数字</td>
                    <td>React.PropTypes.number</td>
                </tr>
                <tr>
                    <td>对象</td>
                    <td>React.PropTypes.object</td>
                </tr>
                <tr>
                    <td>字符串</td>
                    <td>React.PropTypes.string</td>
                </tr>
            </table>
        </div>
    </li>
    <li>
        <p>状态 State</p>
        <div class="desc">
            <h2>状态</h2>
            <h3>State</h3>
            <dl class="accordion">
                <dt>什么是状态</dt>
                <dd>
                    <p>与props不同，state用来表示自身的状态，它是私有的，其父组件或子组件都不知道它是否有state属性，更不知道state里面的值。父组件可以通过属性的形式将state里的值传递给子组件，但是子组件并不知道这个值从何而来。</p>
                    <p>React中这种传递方式是单向数据流。state由某一特定组件所有，只能向下传递。</p>
                    <pre class="code">import React,{Component} from 'react';

class Clock extends Component{
    <span class="note">//组件通过属性接收来自父组件的数据</span>
    constructor(props){
        super(props);
        this.state = {date:new Date()};
    }
    <span class="note">//当组件挂载到DOM中，调用该钩子函数，让浏览器设置一个定时器</span>
    componentDidMount(){
        this.timer = setInterval(()=>{
            this.setState({
                date:new Date()
            });
        },1000);
    }
    <span class="note">//组件卸载之前，清除定时器，释放内存</span>
    componentWillUnmount(){
        clearInterval(this.timer);
        this.timer = null;
    }
    render(){
        return &lt;h1>Hello,现在是{this.state.date.toLocaleTimeString()}&lt;/h1>
    }
}
export default Clock;</pre>
                </dd>
                <dt>State注意事项</dt>
                <dd>
                    <strong>(1)不可以直接修改state的值，用setState()方法完成。</strong>
                    <pre class="code">this.state.comment="hello"; <span class="note">//错误</span>
this.setState({comment:"Hello"});</pre>
                    <strong>(2)状态异步更新</strong>
                    <pre class="code"><span class="note">//如果increment是异步更新的，那么下面设置就可能出错</span>
this.setState({
    counter:this.state.counter + this.prop.increment
});</pre>
                    <p>解决办法是通过回调函数的形式：</p>
                    <pre class="code">this.setState((prevState,props)=>{
    return {
        counter:prevState.counter + props.increment
    }
});</pre>
                    <strong>(3)状态更新会被合并</strong>
                </dd>
            </dl>
            <h3>组件树</h3>
            <p>《React学习手册》书中多次强调，<strong>我们应该尽可能编写无状态的函数式组件</strong>。状态越多越混乱，越难以管理。比较好的做法是，<strong>将数据保存在根组件App中，通过属性一层一层传递给子孙组件，而后代组件通过翻转数据流将增、删、改的结果反映到根组件，从而保证数据的唯一性。</strong></p>
            <pre class="code">class App extends Component {
    constructor(props){
        super(props); <span class="note">//初始化组件</span>
        this.state = { <span class="note">//初始化状态数据</span>
            colors:[]
        }
        this.addColor = this.addColor.bind(this);
        this.removeColor = this.removeColor.bind(this);
        this.rateColor = this.rateColor.bind(this);
    }
    <span class="note">//增</span>
    addColor(title,color){
        const colors = [
            ...this.state.colors,
            {
                id:v4(),
                title,
                color,
                rating:0
            }
        ]
    }
    <span class="note">//删</span>
    removeColor(id){
        <span class="note">//小技巧，利用filter进行函数式操作--删除数据</span>
        const colors = this.state.colors.filter(
            color => color.id !== id
        )
        this.setState(<span class="note">{colors}</span>);
    }
    <span class="note">//改</span>
    rateColor(id,rating){
        const colors = this.state.colors.map(color=>
            (id === color.id)?
                {
                    ...color,
                    rating
                }:
                color
        )
        this.setState({colors})
    }
    render(){
        const {addColor,rateColor,removeColor} = this;
        const {colors} = this.state;
        return (
            &lt;div className="app">
                &lt;AddColorForm onNewColor={addColor} />
                &lt;ColorList colors={colors} onRate={rateColor} onRemove={removeColor} />
            &lt;/div>
        )
    }
}</pre>
        </div>
    </li>
    <li>
        <p>生命周期</p>
        <div class="desc">
            <h2>生命周期</h2>
            <p>了解组件的生命周期将帮助我们<strong>重新审视如何使用它载入数据、集成第三方JavaScript库以及改进组件的性能。</strong></p>
            <h3>挂载生命周期</h3>
            <table>
                <tr>
                    <td>constructor(props)</td>
                    <td>
                        <p>构造函数不是生命周期方法，但是它是state初始化的地方</p>
                    </td>
                </tr>
                <tr>
                    <td>componentWillMount()</td>
                    <td>
                        <p>DOM渲染之前触发，用来初始化第三方脚本库、启动动画、请求数据(在组件被渲染之前需要执行的动作)</p>
                    </td>
                </tr>
                <tr>
                    <td>render()</td>
                    <td></td>
                </tr>
                <tr>
                    <td>componentDidMount()</td>
                    <td>
                        <p>用来创建API请求，调用setState()方法会启动更新生命周期</p>
                        <p>初始化需要用到DOM的第三方JavaScript库</p>
                        <p>启动定时器</p>
                    </td>
                </tr>
                <tr>
                    <td>componentWillUnmount()</td>
                    <td>
                        <p>这里用来清理后台进程，如timer定时器</p>
                    </td>
                </tr>

            </table>
            <h3>更新生命周期</h3>
            <P>更新生命周期会在每次调用setState()方法时启动。</P>
            <table>
                <tr>
                    <td><strong>componentWillReceiveProps(nextProps)</strong></td>
                    <td>
                        <p>当新的属性传给组件后调用</p>
                    </td>
                </tr>
                <tr>
                    <td>shouldComponentUpdate(nextProps,nextState)</td>
                    <td>
                        <p>更新生命周期的守卫，它是一个谓词函数。</p>
                        <p>在组件更新之前触发，新属性当作参数传入，旧属性仍然在当前props中。</p>
                        <p>可以比较新属性和旧属性中某个值是否相等，从而判断是否更新组件。</p>
                    </td>
                </tr>
                <tr>
                    <td>componentWillUpdate(nextProps,nextState)</td>
                    <td></td>
                </tr>
                <tr>
                    <td>componentDidUpdate(prevProps,prevState)</td>
                    <td>
                        <p>更新操作发生之后触发，也就是render()方法之后。</p>
                        <p>之前的状态作为参数传入，因此，可以用来比较，可以显示变化，比如：某值变大了(反应变化)</p>
                    </td>
                </tr>
            </table>
            <h3>React和其他库一起使用</h3>
            <dl class="accordion">
                <dt>React如何发送请求？</dt>
                <dd>
                    <p><strong>使用Fetch发送请求</strong></p>
                    <pre class="code">npm i isomorphic-fetch --save

import fetch from 'isomorphic-fetch';

class CountryList extends Component {
    constructor(props){
        super(props);
        this.state = {
            countryNames:[],
            loading:false
        };
    }
    componentDidMount(){
        this.setState({loading:true}); //设置loading状态
        <span class="note">fetch('url')
            .then(res=>res.json())
            .then(json=>json.map(country=>country.name))
            .then(countryNames=>
                this.setState({coutryNames,loading:false})
            )</span>
    }
    render(){
        ...
    }
}</pre>
                </dd>
                <dt>React中如何使用Echarts?</dt>
                <dd>
                    <pre class="code"><span class="note">//安装echarts到项目中</span>
npm install echarts --save
<span class="note">//引入需要用到的组件</span>
import React,{Component} from 'react';
import echarts from 'echarts/lib/echarts';
import 'echarts/lib/chart/bar';//引入柱状图
import 'echarts/lib/component/tooltip';
import 'echarts/lib/component/title';

class EchartsDemo extends Component{
    <span class="note">//组件渲染之后使用echarts</span>
    componentDidMount(){
        let myChart = echarts.init(document.getElementById('main'));
        myChart.setOption({
            title:{text:'Echarts入门'},
            tooltip:{},
            xAxis:{
                data:['衬衫','羊毛衫','雪纺衫','裤子','高跟鞋','袜子']
            },
            yAxis:{},
            series:[{
                name:'销量',
                type:'bar',
                data:[5,20,36,10,10,20]
            }]
        });
    }

    render(){
        return (
            &lt;div id="main" style={{width:400,height:400}}>&lt;/div>
        );
    }
}
export default EchartsDemo;</pre>
                </dd>
            </dl>
        </div>
    </li>
    <li>
        <p>Redux</p>
        <div class="desc">
            <h2>Redux</h2>
            <h3>Flux</h3>
            <p>Flux为React创建UI提供数据。</p>
            <p>在Flux应用中，State数据交由组件外部的Store进行管理(存储和修改)。</p>
            
            <h4>【例子】：点击提交按钮后发生了什么？</h4>
            <table>
                <tr>
                    <td>1</td>
                    <td><p>点击提交按钮时，会创建一个Action，它提供一组操作指令和需要变更的目标数据。</p></td>
                </tr>
                <tr>
                    <td>2</td>
                    <td><p>Action由Dispatcher分发到相应的Store中。</p></td>
                </tr>
                <tr>
                    <td>3</td>
                    <td><p>Store接收Action后修改State和更新View。</p></td>
                </tr>
            </table>
            <h3>Redux</h3>
            <p>所有的数据存放在一个不可变的对象中（state树），这样可以保证真实单一的数据源。</p>
            <p>不可变对象意味着，更新数据需要更新(替换)整个state对象。而具体需要更新哪些部分，则由Action提供。</p>
            <h4>Action</h4>
            <blockquote>Action是一个JavaScript对象，充当信使的角色--提供如何更新state树的信息。一个不恰当的比喻：mRNA。</blockquote>
            <pre class="code">{
    type:'RATE_COLOR', <span class="note">//Action至少包含一个属性type，【做什么】</span>
    id:'a5685c39...', <span class="note">//用来指明要修改的目标，它是Action的有效载荷数据【目标】</span>
    rating:4 <span class="note">//指明如何修改，有效载荷数据(payload)【怎么做】</span>
}</pre>
            <h4>Reducer</h4>
            <blockquote>Reducer是一类函数，负责加工信息。具体地，传入当前State和Action，加工并返回一个新的State。一个不恰当的比喻：rRNA。</blockquote>
            <pre class="code"></pre>
            <h4>Store</h4>
            <blockquote>
                    Store用来保存和更新State。Store将当前State和Action传递给单个Reducer来更新State。<br>
                    (单个reducer意味着需要将若干个小的reducer装配组合成一个大的reducer。)
            </blockquote>
            <pre class="code">import { createStore,combineReducers } from 'redux';
import {color} from './reducers';  <span class="note">//所有的reducer存放在一个模块里</span>

const store = createStore(
    combineReducers({colors,sort}),  <span class="note">//组合reducer</span>
    initialState <span class="note">//初始化的state树，该参数可以为空</span>
);  <span class="note">//reducer是store的一个零件，作为参数传入</span>
            </pre>
            <p>Store是数据的控制中心，负责存储和更新。<span class="code">store.dispatch(action)</span></p>
            <table>
                <tr>
                    <td>store.getState()</td>
                    <td>返回当前状态State</td>
                </tr>
            </table>
        </div>
    </li>
    <li>
        <p>事件</p>
        <div class="desc">
            <h2>事件</h2>
            <h3>React中的事件</h3>
            <dl class="accordion">
                <dt>事件写成驼峰形式</dt>
                <dd>
                    <pre class="code"><span class="note">//html</span>
&lt;button <span class="note">onclick</span>="handleClick()">按钮&lt;/button>
<span class="note">//React</span>
&lt;button <span class="note">onClick</span>={handleClick}按钮&lt;/button></pre>
                </dd>
                <dt>不能通过return false来阻止默认行为</dt>
                <dd>
                    <p>必须用preventDefault()方法来阻止默认行为</p>
                    <pre class="code">function Link(){
    function handleClick(e){
        e.preventDefault(); <span class="note">//这里e是合成事件，因此不必担心浏览器兼容性问题</span>
    }
    return &lt;a href="#" onClick={handleClick}>;
}</pre>
                </dd>
                <dt>绑定事件注意事项</dt>
                <dd>
                    <p>
                        <strong>(1)ES6中，类方法里的this默认没有指向，需要手动绑定</strong>
                    </p>
                    <p>
                        <strong>(2)注意：异步数据的更新需要用异步的方式更改state值</strong>
                    </p>
                    <pre class="code">import React,{ Component} from 'react';
class Toggle extends Component{
    constructor(props){
        super(props);
        this.state = { isToggleOn:false };
        this.handleClick = this.handleClick.bind(this); <span class="note">//必须绑定this，或者定义handleClick时用箭头函数</span>
    }
    handleClick(){
        <span class="note">//点击事件是异步数据，得用异步的方式</span>
        this.setState(<span class="note">(prevState)=>({
            isToggleOn:!prevState.isToggleOn
        })</span>);
    }
    render(){
        return &lt;button onClick={this.handleClick}>{this.state.isToggleOn ? 'ON':'OFF'}&lt;/button>
    }
}
export default Toggle;</pre>
                </dd>
                <dt>事件处理函数的传参</dt>
                <dd>
                    <pre class="code">&lt;button onClick={e=>this.deleteRow(id,e)}删除&lt;button>
&lt;button onClick={this.deleteRow.bind(this,id)}删除&lt;/button></pre>
                    <p>上面两行代码的效果是一样的。第一个用了ES6的箭头函数语法，使处理函数里的this保持和外界一致。注意：这里的e事件对象必须显式进行传递。</p>
                    <p>第二个采用了ES5中bind()函数，bind()将this绑定为参数中的对象，并返回一个新的函数，那么这里返回绑定了正确this的函数绑定到onClick上。</p>
                </dd>
            </dl>
        </div>
    </li>
    <li>
        <p>列表和键</p>
        <div class="desc">
            <h2>列表和键</h2>
            <h3>列表</h3>
            <p>在angular和vue中，列表是通过ngFor或v-for指令在模板中生成的。而在React中，给我个人的感觉是，将列表从纯数据加工成列表后再插入，函数的味道更重一些。</p>
            <pre class="code"><span class="note">//封装NumberList组件</span>
function NumberList(props){
    const numbers = props.numbers;
    let lis = <span class="note">numbers.map((ele,index)=>&lt;li key={index.toString()}>{ele}&lt;/li>)</span>;
    return &lt;ul>{lis}&lt;/ul>;
}
const numbers = [2,4,6,8,10];
ReactDOM.render(
    &lt;NumberList <span class="note">numbers={numbers}</span>/>,
    document.getElementById('root')
);</pre>
            <p>在这里，我们体会一下组件的好处。组件就是一个函数，它像一个工厂，数据作为原料投入进去，经过处理后，返回要显示的视图对象，最后渲染到DOM中去。这样，就解决了硬编码的问题，实现了数据和样式的分离，让组件可以重用。感觉好美妙！</p>
            <h3>键</h3>
            <blockquote>
                键(Keys)是用来帮助React标识哪一项被修改、添加或移除的。
            </blockquote>
            <h4>如何选择key</h4>
            <p>多数情况，可以使用数据的id作为key；但如果没有稳定的id，可退一步使用数组的索引。注意：如果列表可能会重排序，则不建议用索引作为key，这样会导致性能问题。</p>
            <h3>创建唯一的id</h3>
            <pre class="code">npm i uuid --save  <span class="note">//安装uuid库</span>
import {v4} from 'uuid'

id:v4()</pre>
        </div>
    </li>
    <li>
        <p>表单</p>
        <div class="desc">
            <h2>表单</h2>
            <pre class="code">import React,{Component} from 'react';
class MyForm extends Component{
    constructor(props){
        super(props);
        <span class="note">this.state = {value:""};</span>
        this.handleChange = this.handleChange.bind(this);
    }
    <span class="note">handleChange(e){
        this.setState({
            value:e.target.value
        });
    }</span>
    render(){
        return (&lt;form>
            &lt;label htmlFor="uname">用户名&lt;/label>
            &lt;input <span class="note">value={this.state.value} onChange={this.handleChange}</span>/>
            {this.state.value}
        &lt;/form>);
    }
}

export default MyForm;</pre>
        </div>
    </li>
    <!-- <li>
        <p>Refs和DOM</p>
        <div class="desc">
            <h2>Refs和DOM</h2>
            <p>Ref允许父组件获取到子组件或子元素的引用，这样，父组件就可以获取到子元素中的值了。</p>
        </div>
    </li> -->
    
    <li>
        <p>React封装组件</p>
        <div class="desc">
            <h2>React封装组件</h2>
            <h3>轮播图</h3>
            <dl class="accordion">
                <dt>carousel.js</dt>
                <dd>
                    <pre class="code">import React,{Component} from 'react';
import './carousel.css';
class Carousel extends Component {

    constructor(props){
        super(props);
        <span class="note">//初始化激活的item为第一个</span>
        this.state = {items:props.items,active:0};
        this.next = this.next.bind(this);
        this.prev = this.prev.bind(this);
        this.handleClick = this.handleClick.bind(this);
        this.go = this.go.bind(this);
        this.stop = this.stop.bind(this);
    }

    componentDidMount(){
        <span class="note">//组件挂载到DOM中后，开启定时器</span>
        this.go();
    }

    componentWillUnmount(){
        this.stop();
        this.timer = null;
    }
    go(){
        this.timer = setInterval(this.next,2000);
    }

    stop(){
        clearInterval(this.timer);
    }
    
    changeItem(changeIndex){
        <span class="note">//切换图片实际操作的是当前激活的item的索引，所以，我们只需要操作索引就够了</span>
        let curIndex = this.state.active,
            maxIndex = this.state.items.length - 1;
        
        <span class="note">//图片如何切换，只要得到一个active的结果即可，做成回调</span>
        this.setState({
            active:changeIndex(curIndex,maxIndex)
        });
        this.blockTimer = setTimeout(()=>{
            this.block = false;
            this.blockTimer = null;
        },500);
    }

    prev(){
        this.changeItem((curIndex,maxIndex)=>{
            return (curIndex<=0) ? maxIndex : curIndex-1;
        });
    }

    next(){
        this.changeItem((curIndex,maxIndex)=>{
            return (curIndex>=maxIndex) ? 0 : curIndex+1;
        });
    }
    
    handleClick(event){
        
        if(!this.block) {<span class="note">//只有锁打开时才执行</span>
            
            var title = event.target.getAttribute("data-title");
            if(title=="prev"){
                this.prev();
            }else if(title=="next"){
                this.next();
            }
            this.block = true;
        }
    }

    render(){
        let items = this.state.items;
        let active = this.state.active;
        if(Array.isArray(items)){
            <span class="note">//map遍历，将数据制作成展示用的li</span>
            let lis = items.map((ele,i)=>{
                    return (
                        &lt;li key={i} className={(i==active)?"active":""}>
                            &lt;img src={require('./'+ele.url)}/>
                        &lt;/li>
                    );
                });
            <span class="note">//返回carousel的虚拟DOM对象</span>
            return (
                &lt;div className="carousel" onMouseEnter={()=>{this.stop()}} onMouseLeave={()=>{this.go()}}>
                    &lt;ul className="items">{lis}&lt;/ul>
                    &lt;ul className="indicators">&lt;/ul>
                    &lt;span className="prev" onClick={this.handleClick} data-title="prev">&lt;/span>
                    &lt;span className="next" onClick={this.handleClick} data-title="next">&lt;/span>
                &lt;/div>
            );
        }
        return null;
    }
}

export default Carousel;</pre>
                </dd>
                <dt>carousel.css</dt>
                <dd>
                    <pre class="code">.carousel {
    position: relative;
    width: 800px;
    height: 480px;
    overflow: hidden;
    border-radius: 10px;
    border:5px solid rgba(0,0,0,.3);
}
.carousel .items{
    width: 100%;
    height: 100%;
}
.carousel .items li {
    height:100%;
    position:absolute;
    top:0;
    left:0;
    opacity: 0;
    z-index:1;
    transition: opacity .5s ease;
}
.carousel .items li.active {
    opacity: 1;
    z-index:5;
}
.carousel .items li img {
    height:100%;
}

.carousel .prev,.carousel .next {
    width: 40px;
    height: 60px;
    background-color: rgba(0,0,0,.3);
    position: absolute;
    top:48%;
    color:#fff;
    line-height: 60px;
    text-align: center;
    font-weight:bolder;
    font-family:"calibri";
    z-index:10;
    font-size: 20px;
    transition:all .5s ease;

}
.carousel .prev:hover,.carousel .next:hover{
    background-color:rgba(0,0,0,.5);
    cursor:pointer;
}
.carousel .prev {
    left:-40px;

}
.carousel:hover .prev{
    left:0;
}
.carousel .next {
    right:-40px;
}
.carousel:hover .next{
    right:0;
}
                    </pre>
                </dd>
            </dl>
            <h3>翻页更新组件</h3>
            <dl class="accordion">
                <dt>RotateFresh.js</dt>
                <dd>
<pre class="code">import React, { Component } from 'react';
import './rotatefresh.scss';

class RotateFresh extends Component {

    constructor(props) {
        super(props);
        this.state = {
            data01: '0',
            data02: '0',
            front: '0',
            active: false
        }
    }
    
    shouldComponentUpdate({newValue}){
        const {front} = this.state;
        return newValue !== front;
    }

    componentWillUpdate({ newValue }) {
        const { front, data01, active } = this.state;
        <span class="note">/*
            完成一次翻滚更新流程：
            1) 将新值更新到背部--若前面是data01，则表示data02在后面，反之，data01在后面
            2) 触发一次翻滚效果
            3) 将font值设置成新值
            */</span>
        this.setState(
            (front === data01) ?
            { 
                data02: newValue,
                front: newValue,
                active: !active
            } : 
            { 
                data01: newValue,
                front: newValue,
                active: !active 
            }
        ); 
    }

    render() {
        const { data01, data02, active } = this.state;
        return (
            //注意多个class之间的空格
            &lt;div className={`rotater${active ? ' active' : ''}`}>
                &lt;div>{data01}&lt;/div>
                &lt;div>{data02}&lt;/div>
            &lt;/div>
        )
    }
}
export default RotateFresh;</pre>
                </dd>
                <dt>rotatefresh.scss</dt>
                <dd>
                    <pre class="code">.rotater {
    position:relative;
    float:left;
    width: 80px; //滚动数字容器的宽度，原80px
    height: 70px;
    &>div{
        display:inline-block;
        // border:1px solid #fff; //边框，测试用
        position: absolute;
        left: 0;
        height: 0;
        width: 80px; // 滚动数字的宽度在这里，80px
        height: 70px;
        line-height: 70px;
        color: #ffcc33; // 滚动数字的颜色
        transition: .8s ease-in-out;
        backface-visibility: hidden;
        -webkit-backface-visibility:hidden;	/* Chrome 和 Safari */
        -moz-backface-visibility:hidden; 	/* Firefox */
        -ms-backface-visibility:hidden; 	/* Internet Explorer */
        &:first-child{
            z-index: 2;
            transform: rotateX(0);
            -ms-transform:rotateX(0); 	/* IE 9 */
            -moz-transform:rotateX(0); 	/* Firefox */
            -webkit-transform:rotateX(0); /* Safari 和 Chrome */
            -o-transform:rotateX(0); 	/* Opera */
        }
        &:last-child{
            z-index: 1;
            transform: rotateX(180deg);
            -ms-transform:rotateX(180deg); 	/* IE 9 */
            -moz-transform:rotateX(180deg); 	/* Firefox */
            -webkit-transform:rotateX(180deg); /* Safari 和 Chrome */
            -o-transform:rotateX(180deg); 	/* Opera */
        }
    }
    
    &.active > div:first-child {
        transform: rotateX(180deg);
        -ms-transform:rotateX(180deg); 	/* IE 9 */
        -moz-transform:rotateX(180deg); 	/* Firefox */
        -webkit-transform:rotateX(180deg); /* Safari 和 Chrome */
        -o-transform:rotateX(180deg); 	/* Opera */
    }
    &.active > div:last-child{
        transform: rotateX(0);
        -ms-transform:rotateX(0); 	/* IE 9 */
        -moz-transform:rotateX(0); 	/* Firefox */
        -webkit-transform:rotateX(0); /* Safari 和 Chrome */
        -o-transform:rotateX(0); 	/* Opera */
    }
}
                    </pre>
                </dd>
            </dl>
            <p>使用RotateFresh组件：</p>
            <pre class="code">&lt;RotateFresh <span class="note">newValue={value}</span>/></pre>
        </div>
    </li>
    <li>
        <p>路由</p>
        <div class="desc">
            <h2>路由</h2>
            <dl class="accordion">
                <dt>激活的Link</dt>
                <dd>
                    <p>Link与a不同之处在于，Link知道它自身是否处于激活状态，因此可以用css标识出来。下例
                        <span class="code">activeStyle</span>用来指定链接处于激活状态的样式(行内样式)，
                        <span class="code">activeClassName</span>则用来引用CSS文件中的样式。</p>
                    <pre class="code">// modules/App.js
&lt;li>&lt;Link to="/about" <span class="note">activeStyle={{ color: 'red' }}</span>>About&lt;/Link>&lt;/li>
&lt;li>&lt;Link to="/repos" <span class="note">activeClassName="active"</span>>Repos&lt;/Link>&lt;/li></pre>
                    <p>如果我们不想每次都指定Link的样式，可以将Link封装成组件，在组件内定义好激活的样式，而
                        <span class="code">to=""</span>参数通过prop属性传入到组件内。</p>
                    <pre class="code">import React,{Component} from 'react';
import { Link } from 'react-router';

class NavLink extends Component {
    render(){
        <span class="note">//this.props是父组件传来的参数，是一个数组，这里将它打散(spread)</span>
        return &lt;Link <span class="note">{...this.props}</span>  className="link" activeClassName="active"/>
    }
}

export default NavLink;

<span class="note">//使用NavLink组件</span>
&lt;li className="nav">&lt;<span class="note">NavLink to="/about">About&lt;/NavLink></span>&lt;/li>
&lt;li className="nav">&lt;NavLink to="/repo">Repo&lt;/NavLink>&lt;/li></pre>
                </dd>
                <dt>Url参数</dt>
                <dd>
                    <p>设置
                        <span class="code">Link</span>:</p>
                    <pre class="code">import React,{Component} from 'react';
import NavLink from './NavLink';
class Repos extends Component {
    render(){
        return (
            &lt;div>
                &lt;h2>Repo&lt;/h2>
                &lt;ul>
                    &lt;li><span class="note">&lt;NavLink to="repos/reactjs/react-router">React Router&lt;/NavLink></span>&lt;/li> <span class="note">//(1)点击会改变url，然后该url去匹配设置好的路由</span>
                    &lt;li>&lt;NavLink to="repos/facebook/react">React&lt;/NavLink>&lt;/li>
                &lt;/ul>
                <span class="note">{this.props.children}//(4)父组件通过this.props.children拿到子节点，渲染出来</span>
            &lt;/div>
        );
    }
}
export default Repos;</pre>
                    <p>在根组件中
                        <strong>配置路由。这里使用了路由的嵌套，也就是子路由。</strong>
                    </p>
                    <pre class="code">render(
    (
        &lt;Router history={hashHistory}>
            &lt;Route path="/" component={App}>
                &lt;Route path="about" component={About}/>
                <span class="note">{/*(2)根据设置的路由去找组件Repo*/}</span>
                <span class="note">&lt;Route path="repos" component={Repos}>
                    &lt;Route path=":username/:repoName" component={Repo}/>
                &lt;/Route></span>
            &lt;/Route>
        &lt;/Router>
    ),document.getElementById('app')
)</pre>
                    <p>Repo.js</p>
                    <pre class="code">import React,{Component} from 'react';
class Repo extends Component {
    render(){
        return (
            &lt;div>
                <span class="note">//(3)匹配到Repo组件，但不能在父组件中直接渲染，我把它理解成一个参数，需要父组件处理
                    &lt;h2>{this.props.params.username+" "+this.props.params.repoName}&lt;/h2></span>
            &lt;/div>
        )
    }
}
export default Repo;</pre>
                </dd>
                <dt>小知识点：this.props.children</dt>
                <dd>
                    <p>
                        <span class="code">this.props.children</span>指向该组件的所有子节点。需要注意的是，它的值可能有3种，
                        <strong>若当前组件没有子节点，则为undefined；若有1个子节点，则为object；而若有2个及以上的子节点，则为Array</strong>。最好的处理方式是使用
                        <span class="code">React.Children</span>工具。</p>
                    <pre class="code">
return (&lt;ul>
        {
            <span class="note">React.Children.map(this.props.children,function(value,key){
                return &lt;li>{key}:{value}&lt;/li>
            });</span>
        }
    &lt;/ul>)</pre>
                </dd>
                <dt>Index Routes</dt>
                <dd>
                    <p>Index Routes用来匹配目录为
                        <span class="code">/</span>的情况。</p>
                    <pre class="code">import React,{Component} from 'react';
class Home extends Component {
    render(){
        return (
            &lt;h2>主页&lt;/h2>
        );
    }
}
export default Home;</pre>
                    <p>配置路由：</p>
                    <pre class="code">render((
    &lt;Router history={hashHistory}>
        &lt;Route path="/" component={App}>
            <span class="note">&lt;IndexRoute component={Home}/></span>
            &lt;Route path="about" component={About}/>
        &lt;/Route>
    &lt;/Router>
),document.getElementById('app'))</pre>
                </dd>
                <dt>Index Link</dt>
                <dd>
                    <p>设置主页的路由时，如果使用普通的Link，指向Home组件的
                        <span class="code">/</span>会处于一直激活状态，因为它是根目录。
                        <strong>(1)使用
                            <span class="code">IndexLink</span>可以解决该问题：</strong>
                    </p>
                    <pre class="code">&lt;li className="nav"><span class="note">&lt;IndexLink to="/" activeClassName="active">Home&lt;/IndexLink></span>&lt;/li></pre>
                    <p>
                        <strong>(2)或者在Link上添加属性onlyActiveOnIndex={true}</strong>
                    </p>
                    <pre class="code">&lt;NavLink to="/" <span class="note">onlyActiveOnIndex={true}</span>>Home&lt;/NavLink></pre>
                </dd>
                <dt>干净的url</dt>
                <dd>
                    <p>先前我们的url使用了hack技术--hash。现在浏览器允许js在不发送http请求的情况下操作url。</p>
                    <pre class="code">&lt;Router history={browserHistory}>&lt;/Router></pre>
                    <p>这样做需要配置一下服务器，在package.json中修改：</p>
                    <pre class="code">"scripts": {
    "start": "webpack-dev-server --inline --content-base . <span class="note">--history-api-fallback</span>"
}</pre>
                </dd>
            </dl>

        </div>
    </li>
    <li>
        <p>React+Ant Design</p>
        <div class="desc">
            <h2>Ant Design</h2>
            <h3>create-react-app下安装和配置ant design</h3>
            <pre class="code"><span class="note">//1.下载antd组件包</span>
npm i antd --save

<span class="note">//2.引入自定义配置解决方案，注意，如果使用scss而将配置文件eject出来的话，该操作会出问题</span>
npm i react-app-rewired

<span class="note">//3.修改package.json配置文件</span>
"scripts":{
    "start": "react-app-rewired start", <span class="note">//原：react-scripts</span>
    "build": "react-app-rewired build",
    "test": "react-app-rewired test --env=jsdom",
}

<span class="note">//4.项目根目录新建文件：config-overrides.js</span>
module.exports = function override(config, env) {
    // do stuff with the webpack config...
    return config;
  };

<span class="note">//5.引入babel-plugin-import，用于按需加载组件和样式文件</span>
npm i babel-plugin-import --save-dev

<span class="note">//6.修改config-overrides.js</span>
const { injectBabelPlugin } = require('react-app-rewired');

module.exports = function override(config, env) {
    
    config = injectBabelPlugin(
        ['import',{libraryName:'antd',libraryDirectory:'es',style:'css'}],
        config,
    );
    
    return config;
  };
</pre>
        <p>上述是所有的配置工作，下面是使用：</p>
        <pre class="code">import {Button} from 'antd';</pre>
        <h3>自定义主题</h3>
        <pre class="code"><span class="note">//安装react-app-rewire的less插件</span>
npm i react-app-rewire-less

<span class="note">//修改配置文件</span>
const { injectBabelPlugin } = require('react-app-rewired');
<span class="note">const rewireLess = require('react-app-rewire-less');</span>

  module.exports = function override(config, env) {
    config = injectBabelPlugin(
        <span class="note">['import', { libraryName: 'antd', libraryDirectory: 'es', style: true }],</span> // change importing css to less
      config,
    );
    <span class="note">
    config = rewireLess.withLoaderOptions({
        modifyVars: { "@primary-color": "#1DA57A" },<span class="code">//这里配置主题</span>
        javascriptEnabled: true,
    })(config, env);
    </span>
    return config;
  };</pre>
        <p>配置主题主要是修改通用的变量</p>
        <pre class="code">'@primary-color': '#1890ff',                         // 全局主色
'@link-color': '#1890ff',                            // 链接色
'@success-color': '#52c41a',                         // 成功色
'@warning-color': '#faad14',                         // 警告色
'@error-color': '#f5222d',                           // 错误色
'@font-size-base': '14px',                           // 主字号
'@heading-color': 'rgba(0, 0, 0, .85)',              // 标题色
'@text-color': 'rgba(0, 0, 0, .65)',                 // 主文本色
'@text-color-secondary' : 'rgba(0, 0, 0, .45)',      // 次文本色
'@disabled-color' : 'rgba(0, 0, 0, .25)',            // 失效色
'@border-radius-base': '4px',                        // 组件/浮层圆角
'@border-color-base': '#d9d9d9',                     // 边框色
'@box-shadow-base': '0 2px 8px rgba(0, 0, 0, .15)'  // 浮层阴影</pre>
            <p><a href="https://github.com/ant-design/ant-design/blob/master/components/style/themes/default.less">更多变量名点击这里</a></p>
        </div>

    </li>
</ul>