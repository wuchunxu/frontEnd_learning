<h2>React</h2>
<button class="back">返回</button>
<ul class="menu">
    <li>
        <p>了解React</p>
        <div class="desc">
            <h2>React</h2>
            <h3>概述</h3>
            <p>React包括ReactJS、ReactNative、ReactVR</p>
            <h4>ReactJS</h4>
            <p>ReactJS是一个js库，专注用来实现UI，由Facebook公司开发。</p>
            <h3>Why React?</h3>
            <h4>大量的DOM操作，带来浏览器的性能瓶颈</h4>
            <p>VDOM(Virtual DOM)虚拟DOM</p>
            <h4>维护大量的代码，成本越来越高</h4>
            <p>解决方案：单向数据流</p>
            <h3>何时使用React?</h3>
            <table>
                <tr>
                    <td>Vue</td>
                    <td>渐进式JS框架，可以实现数据操作非常频繁的SPA</td>
                </tr>
                <tr>
                    <td>Angular</td>
                    <td>实现非常频繁数据操作的SPA，定位大型商业项目</td>
                </tr>
                <tr>
                    <td>React</td>
                    <td>ReactJS核心库用来实现UI层，主要考虑频繁的操作DOM</td>
                </tr>
            </table>
            <p>awesome react</p>
            <h3>如何使用React</h3>
            <h4>直接引入对应js文件</h4>
            <h4>采用命令行的方式</h4>
            <pre class="code"><span class="note">//安装工具</span>
npm install create-react-app
<span class="note">//创建app</span>
create-react-app myapp
<span class="note">//安装依赖</span>
npm install
npm start</pre>
            <h3>Hello React</h3>
            <pre class="code">
&lt;script type="text/babel">
    ReactDOM.render(
        &lt;h1>Hello React&lt;/h1>,
        document.getElementById("example")
    );
&lt;/script></pre>
            <h4>Babel</h4>
            <p>将ES6/jsx编译成ES5/js</p>
            <h4>ReactDOM.render(要渲染的元素,容器);</h4>
            <h4>JSX</h4>
            <p>全称：JavaScriptXML，允许在js中调用标签</p>
            <p>如果遇到&lt;，且首字母小写，则以html解析；如果是大小，则是一个组件</p>
            <p>如果遇到{，就会用js来解析并执行花括号中的表达式，并将结果输出到对应标签</p>
            <h3>React 5大核心概念</h3>
            <table>
                <tr>
                    <td>jsx</td>
                    <td></td>
                </tr>
                <tr>
                    <td>ref</td>
                    <td>实现对子组件或元素本身的引用</td>
                </tr>
                <tr>
                    <td>state</td>
                    <td>1)管理数据； 2)数据绑定</td>
                </tr>
                <tr>
                    <td>props</td>
                    <td>属性，用来传值</td>
                </tr>
            </table>
        </div>
    </li>
    <li>
        <p>组件</p>
        <div class="desc">
            <h2>组件</h2>
            <h3>创建组件</h3>
            <pre class="code">var MyHeader = React.createClass({
    render:function(){
        return &lt;h3>这是页头&lt;/h3>
    }
});
ReactDOM.render(
    &lt;MyHeader>&lt;/MyHeader>,
    document.getElementById("example")
);</pre>
            <p>注意点</p>
            <table>
                <tr>
                    <td>1</td>
                    <td><p>变量必须是全驼峰形式，如果是myHeader，则无法显示</p></td>
                </tr>
                <tr>
                    <td>2</td>
                    <td><p>返回的结果，必须有一个顶层的标签</p></td>
                </tr>
                <tr>
                    <td>3</td>
                    <td><p>组件类在渲染模板的时候，返回的第一个元素是不允许直接换行的</p></td>
                </tr>
            </table>

            <h3>复合组件</h3>
            <p>复合组件不是一个新概念，只不过是允许在一个组件中调用其他组件</p>
            <h3>进阶知识</h3>
            <p>每个组件类实例化之后，都有一个props属性，而props对应的数据是一个对象，对象的属性和调用组件时传的属性是一一对应的。但是，有一个例外，this.props.children</p>
            <p>建议通过React.Children.map()方法来对this.props.children执行遍历操作，以防止出现类型错误(没有子元素是undefined，一个是object，多个是array)</p>
            <pre class="code">var MyList = React.createClass({
    render:function(){
        return &lt;ul>
            {
                React.Children.map(this.props.children,function(value,index){
                return value;
                })
            }
        &lt;/ul>
    }
});
ReactDOM.render(&lt;MyList>
        &lt;li>01&lt;/li>
        &lt;li>02&lt;/li>
        &lt;li>03&lt;/li>
    &lt;/MyList>,
document.getElementById("example"));</pre>
            <h3>父子组件之间的通信</h3>
            <h4>父传子</h4>
            <p>通过属性绑定，子组件就可以访问父组件的属性或者方法</p>
            <h4>子传父</h4>
            <p></p>
            <pre class="code">var Child = React.createClass({
    render: function(){
        return &lt;div>
            &lt;h2>子组件&lt;/h2>
            &lt;button onClick={this.handleClick}>发送&lt;/button>
        &lt;/div>
    },
    handleClick:function(){
        this.props.func("hi");
    }

});
var Parent = React.createClass({
    rcvMsg: function(msg){
        console.log("父组件已经接受到信息:%s",msg);
    },
    render: function(){
        return &lt;div>
            &lt;h1>父组件&lt;/h1>
            &lt;Child func={this.rcvMsg}>&lt;/Child>
        &lt;/div>
    }
});
ReactDOM.render(
    &lt;Parent>&lt;/Parent>,
    document.getElementById("example")
);</pre>
            <h4>ref</h4>
            <pre class="code">var MyComponent = React.createClass({
    render: function(){
        return &lt;div>
            &lt;input type="text"  <span class="note">ref="myInput"</span> />
            &lt;button onClick = {this.handleClick}>click me&lt;/button>
        &lt;/div>
    },
    handleClick: function(){
        console.log(this.refs.myInput.value);
    }
});</pre>

            <h3>状态(state)</h3>
            <p>组件中的数据都要交给状态来管理。状态中的数据可以绑定到视图中。</p>
            <table>
                <tr>
                    <td>初始化</td>
                    <td>getInitialState:function(){return {count:1}}</td>
                </tr>
                <tr>
                    <td>读</td>
                    <td>this.state.count</td>
                </tr>
                <tr>
                    <td>写</td>
                    <td>this.setState({count:3})</td>
                </tr>
            </table>

            <pre class="code">var MyComponent = React.createClass({
    render:function(){
        return &lt;div>
            &lt;p><span class="note">{this.state.count}</span>&lt;/p>
                &lt;button <span class="note">onClick={this.add}</span>>点击&lt;/button>
        &lt;/div>
    },
    getInitialState:function(){
        return {
            count:0
        }
    },
    add:function(){
        var temp = this.state.count;
        temp++;
        <span class="note">this.setState({count:temp});</span>
    }
});

ReactDOM.render(
    &lt;MyComponent>&lt;/MyComponent>,
    document.getElementById("example")
);</pre>
            <h4>注意事项</h4>
            <p>不允许在组件的render方法中执行任何和状态相关的操作</p>
            <p>如何修改状态：<span class="code">this.setState({count:1})</span>该方法通知react框架，对比当前VDOM和DOM，找到真正需要更新的元素，以求最大程度减少操作DOM的次数</p>
            <h3>组件的生命周期</h3>
            <p>自定义组件的生命周期主要由三种状态进行管理，它们负责通知组件当前所处的状态，应该执行生命周期中哪个步骤，是否可以更新state。</p>
            <h4>钩子函数</h4>
            <table>
                <tr>
                    <td>componentWillMount</td>
                    <td>挂载之前</td>
                </tr>
                <tr>
                    <td>componentDidMount</td>
                    <td>挂载完成</td>
                </tr>
                <tr>
                    <td>componentWillUpdate</td>
                    <td>更新前</td>
                </tr>
                <tr>
                    <td>componentDidUpdate</td>
                    <td>更新后</td>
                </tr>
                <tr>
                    <td>componentWillUnmount</td>
                    <td>卸载/删除之前</td>
                </tr>
            </table>
        </div>
    </li>

</ul>