<h2>React</h2>
<button class="back">返回</button>
<ul class="menu">
    <li>
        <p>了解React</p>
        <div class="desc">
            <h2>React</h2>
            <h3>概述</h3>
            <p>React包括ReactJS、ReactNative、ReactVR</p>
            <h4>ReactJS</h4>
            <p>ReactJS是一个js库，专注用来实现UI，由Facebook公司开发。</p>
            <h3>Why React?</h3>
            <h4>虚拟DOM</h4>
            <p>大量的DOM操作，带来浏览器的性能瓶颈</p>
            <h4>单向数据流</h4>
            <h4>维护大量的代码，成本越来越高</h4>
            <p>解决方案：单向数据流</p>
            <h3>何时使用React?</h3>
            <table>
                <tr>
                    <td>Vue</td>
                    <td>渐进式JS框架，可以实现数据操作非常频繁的SPA</td>
                </tr>
                <tr>
                    <td>Angular</td>
                    <td>实现非常频繁数据操作的SPA，定位大型商业项目</td>
                </tr>
                <tr>
                    <td>React</td>
                    <td>ReactJS核心库用来实现UI层，主要考虑频繁的操作DOM，关注浏览器性能问题</td>
                </tr>
            </table>
            <p>awesome react</p>
            <h3>使用React</h3>
            <h4>直接引入对应js文件</h4>
            <h4>采用命令行的方式</h4>
            <pre class="code"><span class="note">//安装工具</span>
npm install -g create-react-app
<span class="note">//创建app</span>
create-react-app myapp
<span class="note">//安装依赖</span>
npm install
npm start</pre>
            <h3>Hello React</h3>
            <pre class="code">
&lt;script type="text/babel">
    ReactDOM.render(
        &lt;h1>Hello React&lt;/h1>,
        document.getElementById("example")
    );
&lt;/script></pre>
            <h4>Babel</h4>
            <p>将ES6/jsx编译成ES5/js</p>
            <h4>ReactDOM.render(要渲染的元素,容器);</h4>
            <h4>JSX</h4>
            <p>全称：JavaScriptXML，允许在js中调用标签</p>
            <p>如果遇到&lt;，且首字母小写，则以html解析；如果是大小，则是一个组件</p>
            <p>如果遇到{，就会用js来解析并执行花括号中的表达式，并将结果输出到对应标签</p>
            <h3>React 5大核心概念</h3>
            <table>
                <tr>
                    <td>jsx</td>
                    <td></td>
                </tr>
                <tr>
                    <td>ref</td>
                    <td>实现对子组件或元素本身的引用</td>
                </tr>
                <tr>
                    <td>state</td>
                    <td>1)管理数据； 2)数据绑定</td>
                </tr>
                <tr>
                    <td>props</td>
                    <td>属性，用来传值</td>
                </tr>
            </table>
        </div>
    </li>
    <li>
        <p>组件</p>
        <div class="desc">
            <h2>组件</h2>
            <h3>创建组件</h3>
            <pre class="code">var MyHeader = React.createClass({
    render:function(){
        return &lt;h3>这是页头&lt;/h3>
    }
});
ReactDOM.render(
    &lt;MyHeader>&lt;/MyHeader>,
    document.getElementById("example")
);</pre>
            <p>注意点</p>
            <table>
                <tr>
                    <td>1</td>
                    <td><p>变量必须是全驼峰形式，如果是myHeader，则无法显示</p></td>
                </tr>
                <tr>
                    <td>2</td>
                    <td><p>返回的结果，必须有一个顶层的标签</p></td>
                </tr>
                <tr>
                    <td>3</td>
                    <td><p>组件类在渲染模板的时候，返回的第一个元素是不允许直接换行的</p></td>
                </tr>
            </table>

            <h3>复合组件</h3>
            <p>复合组件不是一个新概念，只不过是允许在一个组件中调用其他组件</p>
            <h3>进阶知识</h3>
            <p>每个组件类实例化之后，都有一个props属性，而props对应的数据是一个对象，对象的属性和调用组件时传的属性是一一对应的。但是，有一个例外，this.props.children</p>
            <p>建议通过React.Children.map()方法来对this.props.children执行遍历操作，以防止出现类型错误(没有子元素是undefined，一个是object，多个是array)</p>
            <pre class="code">var MyList = React.createClass({
    render:function(){
        return &lt;ul>
            {
                React.Children.map(this.props.children,function(value,index){
                return value;
                })
            }
        &lt;/ul>
    }
});
ReactDOM.render(&lt;MyList>
        &lt;li>01&lt;/li>
        &lt;li>02&lt;/li>
        &lt;li>03&lt;/li>
    &lt;/MyList>,
document.getElementById("example"));</pre>
            <h3>父子组件之间的通信</h3>
            <h4>父传子</h4>
            <p>通过属性绑定，子组件就可以访问父组件的属性或者方法</p>
            <h4>子传父</h4>
            <p></p>
            <pre class="code">var Child = React.createClass({
    render: function(){
        return &lt;div>
            &lt;h2>子组件&lt;/h2>
            &lt;button onClick={this.handleClick}>发送&lt;/button>
        &lt;/div>
    },
    handleClick:function(){
        this.props.func("hi");
    }

});
var Parent = React.createClass({
    rcvMsg: function(msg){
        console.log("父组件已经接受到信息:%s",msg);
    },
    render: function(){
        return &lt;div>
            &lt;h1>父组件&lt;/h1>
            &lt;Child func={this.rcvMsg}>&lt;/Child>
        &lt;/div>
    }
});
ReactDOM.render(
    &lt;Parent>&lt;/Parent>,
    document.getElementById("example")
);</pre>
            <h4>ref</h4>
            <pre class="code">var MyComponent = React.createClass({
    render: function(){
        return &lt;div>
            &lt;input type="text"  <span class="note">ref="myInput"</span> />
            &lt;button onClick = {this.handleClick}>click me&lt;/button>
        &lt;/div>
    },
    handleClick: function(){
        console.log(this.refs.myInput.value);
    }
});</pre>

            <h3>状态(state)</h3>
            <p>组件中的数据都要交给状态来管理。状态中的数据可以绑定到视图中。</p>
            <table>
                <tr>
                    <td>初始化</td>
                    <td>getInitialState:function(){return {count:1}}</td>
                </tr>
                <tr>
                    <td>读</td>
                    <td>this.state.count</td>
                </tr>
                <tr>
                    <td>写</td>
                    <td>this.setState({count:3})</td>
                </tr>
            </table>

            <pre class="code">var MyComponent = React.createClass({
    render:function(){
        return &lt;div>
            &lt;p><span class="note">{this.state.count}</span>&lt;/p>
                &lt;button <span class="note">onClick={this.add}</span>>点击&lt;/button>
        &lt;/div>
    },
    getInitialState:function(){
        return {
            count:0
        }
    },
    add:function(){
        var temp = this.state.count;
        temp++;
        <span class="note">this.setState({count:temp});</span>
    }
});

ReactDOM.render(
    &lt;MyComponent>&lt;/MyComponent>,
    document.getElementById("example")
);</pre>
            <h4>注意事项</h4>
            <p>不允许在组件的render方法中执行任何和状态相关的操作</p>
            <p>如何修改状态：<span class="code">this.setState({count:1})</span>该方法通知react框架，对比当前VDOM和DOM，找到真正需要更新的元素，以求最大程度减少操作DOM的次数</p>
            <h3>组件的生命周期</h3>
            <p>自定义组件的生命周期主要由三种状态进行管理，它们负责通知组件当前所处的状态，应该执行生命周期中哪个步骤，是否可以更新state。</p>
            <h4>钩子函数</h4>
            <table>
                <tr>
                    <td>componentWillMount</td>
                    <td>挂载之前</td>
                </tr>
                <tr>
                    <td>componentDidMount</td>
                    <td>挂载完成</td>
                </tr>
                <tr>
                    <td>componentWillUpdate</td>
                    <td>更新前</td>
                </tr>
                <tr>
                    <td>componentDidUpdate</td>
                    <td>更新后</td>
                </tr>
                <tr>
                    <td>componentWillUnmount</td>
                    <td>卸载/删除之前</td>
                </tr>
            </table>
        </div>
    </li>
    <li>
        <p>JSX</p>
        <div class="desc">
            <h2>JSX</h2>
            <h3>JSX基础知识</h3>
            <p>JSX是JavaScript的一种扩展语法</p>
            <h4>可以嵌入表达式</h4>
            <pre class="code">const user = {
    firstname:"Wu",
    lastname:"Chunxu"
};
<span class="note">//如果JSX表达式换行，建议加上括号</span>            
const element = (<span class="note">&lt;h1>Hello,{user.firstname+user.lastname}&lt;/h1></span>);

ReactDOM.render(
    element, 
    document.getElementById('root')
);</pre>
            <p>JSX编译后变成js对象。我们可以这么理解，JSX语法只是为了简化js生成DOM元素对象，那么，我们就可以把JSX当作js对象。它可以作为参数、返回值或者赋值给某个变量。</p>
            <h4>属性中插入表达式</h4>
            <p>属性的值如果是一个变量，那么就要用到表达式，JSX语法规定，js表达式写在<span class="code">{}</span>内，而普通的字符串则写在引号<span class="code">""</span>内</p>
            <pre class="code">const element = &lt;img src=<span class="note">{user.avatarUrl}</span>>&lt;/img>;</pre>
            <h4>jsx默认防止注入攻击(XSS)</h4>
            <h4>JSX的写法偏向于JavaScript</h4>
            <p>因此，html中的属性要采用js中的驼峰写法。</p>
            <pre class="code">const element = (
    &lt;h1 <span class="note">className="greeting"</span>>Hello World&lt;/h1>
);</pre>
            <h3>元素渲染</h3>
            <p>像下面element元素，它编译后只是一个普通的对象，非常容易创建，ReactDOM负责更新DOM。</p>
            <pre class="code"><span class="note">//html文件中应该有一个根DOM节点，它的内容由ReactDOM来管理。单纯用React构建的应用只有一个根，而将React嵌入到现有的app则可能有多个根DOM节点。</span>
&lt;div id="root">&lt;/div>
        
const element = &lt;h1>Hello,world&lt;/h1>
ReactDOM.render(
    element,
    document.getElementById('root')
);</pre>
            <h4>更新已经渲染的元素</h4>
            <pre class="code">function tick(){
    const element = (
        &lt;div>
            &lt;h1>Hello,world&lt;/h1>
            &lt;h2>现在是{new Date().toLocaleTimeString()}&lt;/h2>
        &lt;/div>
    );
    ReactDOM.render(
        element, 
        document.getElementById('root')
    );
}
setInterval(tick,1000); <span class="note">//每隔1秒钟，重新渲染</span></pre>
            <p>要特别注意的是，React元素是immutable，一旦创建无法修改(包括子元素和属性)，只能重新渲染。ReactDOM会检查当前元素与之前版本的差异，只对有必要更新的DOM进行更新。</p>
            <p>Angular中也可以使用immutable特性</p>
        </div>
    </li>
    <li>
        <p>组件</p>
        <div class="desc">
            <h2>组件和属性</h2>
            <h3>组件</h3>
            <p>组件类似JavaScript中的函数，接收输入(props)，返回React元素，用以描述屏幕要显示的内容。</p>
            <dl class="accordion">
                <dt>定义组件</dt>
                <dd>
                    <p>组件是一个类，在ES6之前没有类的概念，也可以用构造函数的写法。</p>
                    <strong>函数式组件写法</strong>
                    <pre class="code">function Welcome(props){
    return &lt;h1>Hello,{props.name}&lt;/h1>
}</pre>
                    <strong>ES6类的写法</strong>
                    <pre class="code">import React,{Component} from 'react';
import ReactDOM from 'react-dom';

class Welcome extends Component{
    render(){
        return &lt;h1>Hello,{this.props.name}&lt;/h1>
    }
}</pre>
                </dd>
                <dt>使用组件</dt>
                <dd>
                    <p>在使用组件时，JSX的属性会被封装在一个对象中，如下例，会被封装到{name:"wuchunxu"},这个对象名为props</p>
                    <pre class="code">ReactDOM.render(
    &lt;div> <span class="note">//必须有根标签</span>
        &lt;Welcome name="Tom"/>,
        &lt;Welcome name="Jerry" /> <span class="note">//空标签必须闭合</span>
    &lt;/div>,
    document.getElementById("root")
);</pre>
                </dd>
            </dl>
            <h3>属性</h3>
            <p>属性就是参数，用来传递值。注意：<strong>组件无法修改props对象，所有的组件必须是纯函数(不能修改输入)。</strong></p>
        </div>
    </li>
    <li>
        <p>状态</p>
        <div class="desc">
            <h2>状态</h2>
            <h3>State</h3>
            <dl class="accordion">
                <dt>什么是状态</dt>
                <dd>
                    <p>与props不同，state用来表示自身的状态，它是私有的，其父组件或子组件都不知道它是否有state属性，更不知道state里面的值。父组件可以通过属性的形式将state里的值传递给子组件，但是子组件并不知道这个值从何而来。</p>
                    <p>React中这种传递方式是单向数据流。state由某一特定组件所有，只能向下传递。</p>
                    <pre class="code">import React,{Component} from 'react';

class Clock extends Component{
    <span class="note">//组件通过属性接收来自父组件的数据</span>
    constructor(props){
        super(props);
        this.state = {date:new Date()};
    }
    <span class="note">//当组件挂载到DOM中，调用该钩子函数，让浏览器设置一个定时器</span>
    componentDidMount(){
        this.timer = setInterval(()=>{
            this.setState({
                date:new Date()
            });
        },1000);
    }
    <span class="note">//组件卸载之前，清除定时器，释放内存</span>
    componentWillUnmount(){
        clearInterval(this.timer);
        this.timer = null;
    }
    render(){
        return &lt;h1>Hello,现在是{this.state.date.toLocaleTimeString()}&lt;/h1>
    }
}
export default Clock;</pre>
                </dd>
                <dt>State注意事项</dt>
                <dd>
                    <strong>(1)不可以直接修改state的值，用setState()方法完成。</strong>
                    <pre class="code">this.state.comment="hello"; <span class="note">//错误</span>
this.setState({comment:"Hello"});</pre>
                    <strong>(2)状态异步更新</strong>
                    <pre class="code"><span class="note">//如果increment是异步更新的，那么下面设置就可能出错</span>
this.setState({
    counter:this.state.counter + this.prop.increment
});</pre>
                    <p>解决办法是通过回调函数的形式：</p>
                    <pre class="code">this.setState((prevState,props)=>{
    return {
        counter:prevState.counter + props.increment
    }
});</pre>
                    <strong>(3)状态更新会被合并</strong>
                </dd>
            </dl>
        </div>
    </li>
    <li>
        <p>事件</p>
        <div class="desc">
            <h2>事件</h2>
            <h3>React中的事件</h3>
            <dl class="accordion">
                <dt>事件写成驼峰形式</dt>
                <dd>
                    <pre class="code"><span class="note">//html</span>
&lt;button <span class="note">onclick</span>="handleClick()">按钮&lt;/button>
<span class="note">//React</span>
&lt;button <span class="note">onClick</span>={handleClick}按钮&lt;/button></pre>
                </dd>
                <dt>不能通过return false来阻止默认行为</dt>
                <dd>
                    <p>必须用preventDefault()方法来阻止默认行为</p>
                    <pre class="code">function Link(){
    function handleClick(e){
        e.preventDefault(); <span class="note">//这里e是合成事件，因此不必担心浏览器兼容性问题</span>
    }
    return &lt;a href="#" onClick={handleClick}>;
}</pre>
                </dd>
                <dt>绑定事件注意事项</dt>
                <dd>
                    <p><strong>(1)ES6中，类方法里的this默认没有指向，需要手动绑定</strong></p>
                    <p><strong>(2)注意：异步数据的更新需要用异步的方式更改state值</strong></p>
                    <pre class="code">import React,{ Component} from 'react';
class Toggle extends Component{
    constructor(props){
        super(props);
        this.state = { isToggleOn:false };
        this.handleClick = this.handleClick.bind(this); <span class="note">//必须绑定this，或者定义handleClick时用箭头函数</span>
    }
    handleClick(){
        <span class="note">//点击事件是异步数据，得用异步的方式</span>
        this.setState(<span class="note">(prevState)=>({
            isToggleOn:!prevState.isToggleOn
        })</span>);
    }
    render(){
        return &lt;button onClick={this.handleClick}>{this.state.isToggleOn ? 'ON':'OFF'}&lt;/button>
    }
}
export default Toggle;</pre>
                </dd>
                <dt>事件处理函数的传参</dt>
                <dd>
                    <pre class="code">&lt;button onClick={e=>this.deleteRow(id,e)}删除&lt;button>
&lt;button onClick={this.deleteRow.bind(this,id)}删除&lt;/button></pre>
                    <p>上面两行代码的效果是一样的。第一个用了ES6的箭头函数语法，使处理函数里的this保持和外界一致。注意：这里的e事件对象必须显式进行传递。</p>
                    <p>第二个采用了ES5中bind()函数，bind()将this绑定为参数中的对象，并返回一个新的函数，那么这里返回绑定了正确this的函数绑定到onClick上。</p>
                </dd>
            </dl>
        </div>
    </li>
</ul>