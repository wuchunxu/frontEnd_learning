<h2>jQuery</h2>
<button class="back">返回</button>
<ul class="menu">
	<li>
		<p>学习新框架的方法</p>
		<div class="desc">
			<h2>学习新框架的方法</h2>
			<h3>上官网看，是什么</h3>
			<h3>看快速入门</h3>
			<h3>下载手册，备查</h3>
		</div>
	</li>
	<li>
		<p>了解jQuery</p>
		<div class="desc">
			<h2>jQuery</h2>
			<h3>jQuery</h3>
			<p>jQuery是第三方极简化DOM操作的函数库。简化体现在以下几个方面：<em>DOM操作(增删改查)、事件绑定、动画效果、Ajax</em>。</p>
			<p>学习jQuery实际还是在学习DOM，因为它<strong>只是API的简化</strong>。</p>
			<p>函数库：<strong>jQuery中都是函数</strong>，用函数解决一切问题。</p>
			<p>jQuery解决了大部分浏览器兼容性问题。</p>
			<h3>下载</h3>
			<h4>jQuery版本</h4>
			<table>
				<tr>
					<th>版本</th>
					<th>特性</th>
				</tr>
				<tr>
					<td>1.x</td>
					<td>兼容旧浏览器，如IE8</td>
				</tr>
				<tr>
					<td>2.x</td>
					<td>不再兼容旧浏览器</td>
				</tr>
				<tr>
					<td>3.x</td>
					<td>不再兼容旧浏览器，提供新特性</td>
				</tr>
			</table>
			<h4>压缩版和未压缩版的区别</h4>
			<table>
				<tr>
					<th>压缩/未压缩</th>
					<th>特点</th>
				</tr>
				<tr>
					<td>x.js(未压缩)</td>
					<td><p>包含完备的注释，格式，变量名，可读性好。但体积大，不便于传输。适用于学习和开发阶段使用</p></td>
				</tr>
				<tr>
					<td>x.min.js(压缩)</td>
					<td><p>体积小，便于传输。去除注释和格式，变量名极简化，可读性差。生产环境使用。</p></td>
				</tr>
			</table>
			<h3>引入</h3>
			<h4>CDN引入</h4>
			<p>什么是CDN：内容分发网络，可根据客户端到服务器的网络状况和访问量智能选择最优的服务器下载资源。</p>
			<h4>本地</h4>
			<p>将jQuery.js下载到项目文件夹中</p>
			<h3>笔试题</h3>
			<h4>jQuery 3.x更新了哪些内容</h4>
			<p>1) 在严格模式下运行</p>
			<p>2) 支持for..of循环，代替$.each()</p>
			<p>3) 新动画API：requestAnimationFrame()</p>
			<p>4) 支持Promise</p>
			<p>...</p>
		</div>
	</li>
	<li>
		<p>jQuery的原理</p>
		<div class="desc">
			<h2>jQuery的原理</h2>
			<h3>“jQuery类型”的构造函数和原型对象</h3>
			<p>引入jquery.js文件，其实是在全局中添加一种新的类型<em>jQuery</em>。</p>
			<table>
				<tr>
					<td>构造函数jQuery</td>
					<td><p>用于创建jquery类型的子对象。</p></td>
				</tr>
				<tr>
					<td>原型对象jquery.fn</td>
					<td><span class="code">jQuery.fn === jQuery.prototype//true</span></td>
				</tr>
			</table>
			<h3>创建jQuery对象</h3>
			<p>jQuery对象是一种类数组对象，用来封装DOM对象，并提供对DOM对象执行操作的简化版API。</p>
			<h4>通过选择器创建对象</h4>
			<p>按照选择器，先查找满足条件的所有元素，保存到jQuery对象中。那么就可以用jQuery对象的API来操作保存在jQuery对象中的DOM元素了。<span class="code">var jq = $("selector");</span>原理如下：</p>
			<pre class="code unimportant">//原来以new方式创建对象
var jq = new jQuery("selector");
//但是比较麻烦，于是写了工厂函数，以简化对象创建
function jQuery("selector"){
	return new jQuery.fn.init("selector");
}
//所以可以这么创建jQuery对象
var jq = jQuery("selector");
//jQuery单词太长，又封装了$，于是可以这样创建对象
var jq = $("selector");</pre>
			<h4>给出DOM元素创建对象</h4>
			<p>将现有元素包装进jQuery对象中。</p>
			<pre class="code">var $ele = $("DOM元素");
$(this);
$(e.target);</pre>
			<h3>jQuery API三大特点</h3>
			<h4>API一个函数2个功能</h4>
			<p>给新值，修改；不给新值，就读取。</p>
			<h4>自带遍历</h4>
			<p>对jQuery对象整体调用一次API，等效于对内部每个元素都调用一次API</p>
			<h4>链式操作</h4>
			<p>每个函数都返回正在操作的jq对象: 链式操作!</p>
			<h3>注意点</h3>
			<p>1) 尽量减少$()的使用，因为每次都会创建jQuery对象，耗费内存</p>
			<p>2) 尽量减少查找的次数，因为查找是遍历，反复查找效率低</p>
		</div>
	</li>
	<li>
		<p>查找元素--选择器查找</p>
		<div class="desc">
			<h2>查找元素</h2>
			<h3>按选择器查找</h3>
			<p>jQuery支持所有CSS选择器，并自定义扩展了一些。</p>
			<table>
				<tr>
					<th>分类</th>
					<th>选择器</th>
					<th>备注</th>
				</tr>
				<tr>
					<td rowspan="5">基本选择器(同CSS)</td>
					<td>$("#id")</td>
					<td><p>id选择器</p></td>
				</tr>
				<tr>
					<td>$(".classname")</td>
					<td><p>类选择器</p></td>
				</tr>
				<tr>
					<td>$("div")</td>
					<td><p>标签选择器</p></td>
				</tr>
				<tr>
					<td>$("*")</td>
					<td><p>通配符选择器</p></td>
				</tr>
				<tr>
					<td>$("#box1,.red")</td>
					<td><p>群组选择器</p></td>
				</tr>
				<tr>
					<td rowspan="4">层级选择器(同CSS)</td>
					<td>$(".menu li")</td>
					<td><p>后代选择器</p></td>
				</tr>
				<tr>
					<td>$(".menu>ul")</td>
					<td><p>子元素选择器</p></td>
				</tr>
				<tr>
					<td>$(".btn+.btn")</td>
					<td><p>相邻兄弟选择器</p></td>
				</tr>
				<tr>
					<td>$("p~div")</td>
					<td><p>通用兄弟选择器</p></td>
				</tr>
				<tr>
					<td rowspan="4">子元素过滤选择器<br>(同CSS)</td>
					<td>li:first-child</td>
					<td><p>选择每个ul下第一个li</p></td>
				</tr>
				<tr>
					<td>li:last-child</td>
					<td><p>选择每个ul下最后一个li</p></td>
				</tr>
				<tr>
					<td>li:nth-child(odd/even/i)</td>
					<td></td>
				</tr>
				<tr>
					<td>:only-child</td>
					<td></td>
				</tr>
				<tr>
					<td rowspan="3" style="background:greenyellow;">基本过滤<br>(位置过滤)(jQuery新增)</td>
					<td>:first/last</td>
					<td>只能选中第一个ul下第一个li</td>
				</tr>
				<tr>
					<td>:gt/lt/eq(i)</td>
					<td>大于/小于/等于(i)</td>
				</tr>
				<tr>
					<td>:even/odd</td>
					<td><p></p></td>
				</tr>
				<tr>
					<td rowspan="6">属性过滤(同CSS)</td>
					<td>[属性名]</td>
					<td></td>
				</tr>
				<tr>
					<td>[属性名=value]</td>
					<td></td>
				</tr>
				<tr>
					<td>[属性名^=value]</td>
					<td></td>
				</tr>
				<tr>
					<td>[属性名$=value]</td>
					<td></td>
				</tr>
				<tr>
					<td>[属性名*=value]</td>
					<td></td>
				</tr>
				<tr>
					<td>[属性名!=value]</td>
					<td></td>
				</tr>
				<tr>
					<td rowspan="2">可见性过滤</td>
					<td>:hidden</td>
					<td><p>只能选择type="hidden"和display:"none"</p></td>
				</tr>
				<tr>
					<td>:visible</td>
					<td></td>
				</tr>
				<tr>
					<td rowspan="5" style="background:greenyellow;">内容过滤(jQuery特有)</td>
					<td>:parent</td>
					<td>非空元素，相当于:not(:empty)</td>
				</tr>
				<tr>
					<td>:empty</td>
					<td>空元素</td>
				</tr>
				<tr>
					<td>:contains(text)</td>
					<td>内容包含指定文本</td>
				</tr>
				<tr>
					<td>:has(.close)</td>
					<td>选中元素，其后代包含.close</td>
				</tr>
				<tr>
					<td>:not(:has(.close))</td>
					<td>选中元素，其后代没有.close</td>
				</tr>
				<tr>
					<td rowspan="4">状态过滤</td>
					<td>:enabled</td>
					<td></td>
				</tr>
				<tr>
					<td>:disabled</td>
					<td></td>
				</tr>
				<tr>
					<td>:checked</td>
					<td></td>
				</tr>
				<tr>
					<td>:selected</td>
					<td></td>
				</tr>
				<tr>
					<td style="background:greenyellow;">表单过滤(jQuery特有)</td>
					<td>:type</td>
					<td>:text :password :submit : reset :button
					<p>:input包含input、textarea</p></td>
				</tr>
			</table>
			<p>jquery特有的位置过滤器原理是，将所有符合条件的元素放在一个集合内，统一编号，从0开始。</p>
			<p>这里要特别注意<em>CSS中子元素过滤选择器</em>和<em>jQuery特有的位置过滤选择器</em>之间的区别。利用过滤选择器，我们可以很轻松的操作表格，如设置表格隔行变色，或者设置表格列变色。</p>
			<p>通过jQuery学习，我们以后绑定事件一律使用<span class="code">data-XXX</span>自定义属性的形式。</p>
		</div>
	</li>
	<li>
		<p>查找元素--节点关系查找</p>
		<div class="desc">
			<h2>查找元素--节点关系查找</h2>
			<h3>按节点关系查找</h3>
			<table>
				<tr>
					<th>#</th>
					<th>jQuery</th>
					<th>DOM</th>
				</tr>
				<tr>
					<td rowspan="4">父子关系</td>
					<td>.parent</td>
					<td>.parentNode</td>
				</tr>
				<tr>
					<td>.children("selector")</td>
					<td>.children</td>
				</tr>
				<tr>
					<td>.children(":first")<br>
						.children().first()</td>
					<td>.firstElementChild</td>
				</tr>
				<tr>
					<td>.children(":last")<br>
						.children().last()</td>
					<td>.lastElementChild</td>
				</tr>
				<tr>
					<td rowspan="3">兄弟关系</td>
					<td>.prev()
						<br>.next()</td>
					<td></td>
				</tr>
				<tr>
					<td>.prevAll()<br>.nextAll("selector")</td>
					<td></td>
				</tr>
				<tr>
					<td>siblings("selector");</td>
					<td></td>
				</tr>
			</table></div>
	</li>
	<li>
		<p>DOM操作</p>
		<div class="desc">
			<h2>DOM操作</h2>
			<h3>修改</h3>
			<h4>修改内容</h4>
			<table>
				<tr>
					<td>HTML代码片段</td>
					<td>.html()</td>
					<td>.innerHTML</td>
				</tr>
				<tr>
					<td>纯文本内容</td>
					<td>.text()</td>
					<td>.textContent</td>
				</tr>
				<tr>
					<td>表单元素的值</td>
					<td>.val()</td>
					<td>.value</td>
				</tr>
				<tr>
					<td>清空内容</td>
					<td>.empty()</td>
					<td>.innerHTML = "";</td>
				</tr>
			</table>
			<h4>修改属性</h4>
			<table>
				<tr>
					<td>HTML标准属性</td>
					<td>.attr("属性名"[,"值"])</td>
					<td>.属性名</td>
				</tr>
				<tr>
					<td>状态属性</td>
					<td>.prop("属性名"[,boolean])</td>
					<td>.属性名</td>
				</tr>
				<tr>
					<td>自定义属性</td>
					<td>.attr("自定义属性")/.data()</td>
					<td>.getAttribute("自定义属性")/.dataset.属性名</td>
				</tr>
			</table>
			<h4>修改样式</h4>
			<table>
				<tr>
					<td>css属性</td>
					<td>.css("属性名"[,"value"])</td>
					<td>.style.属性名<br>如果是获取，自动调用getComputedStyle()</td>
				</tr>
				<tr>
					<td rowspan="4">class的操作</td>
					<td>hasClass("red")</td>
					<td></td>
				</tr>
				<tr>
					<td>addClass()</td>
					<td></td>
				</tr>
				<tr>
					<td>removeClass()</td>
					<td></td>
				</tr>
				<tr>
					<td>toggleClass()</td>
					<td></td>
				</tr>
			</table>
			<h3>添加</h3>
			<h4>创建新元素</h4>
			<table>
				<tr>
					<td rowspan="4">添加元素</td>
					<td rowspan="2">末尾追加</td>
					<td>$parent.append($ele)</td>
					<td>//return $parent</td>
				</tr>
				<tr>
					<td>$ele.appendTo($parent)</td>
					<td>//return $ele</td>
				</tr>
				<tr>
					<td rowspan="2">开头插入</td>
					<td>$parent.prepend($ele)</td>
					<td>//return $parent</td>
				</tr>
				<tr>
					<td>$ele.prependTo($parent)</td>
					<td>//return $ele</td>
				</tr>
			</table>
			<p>
				<strong>注意：attr()和prop()的区别</strong>
			</p>
			<h3>删除/替换/克隆</h3>
			<table>
				<tr>
					<td>删除</td>
					<td>$ele.remove();</td>
				</tr>
				<tr>
					<td>替换</td>
					<td>$ele.replaceWith(新元素);<br>$(新元素).replaceAll()</td>
				</tr>
				<tr>
					<td>克隆</td>
					<td>.clone()</td>
				</tr>
			</table>
			<h3>事件绑定</h3>
			<h4>jQuery中共有几种事件绑定方法，分别有什么特点？</h4>
			<h5>bind</h5>
			<pre class="code">bind("click",handle)</pre>
			<p>bind是addEventListener()的简化版。</p>
			<h5>unbind</h5>
			<pre class="code">.unbind("click",handle)//移除指定事件上的一个处理函数
.unbind("click")//移除指定事件上的所有处理函数
.unbind()//移除所有事件所有处理函数
			</pre>
			<h5>one</h5>
			<pre class="code">.one("事件名",handler)</pre>
			<p>one函数绑定的事件只能触发一次，触发后，自动解绑。</p>
			<h5>delegate</h5>
			<pre class="code">$parent.delegate("selector","click",handle)</pre>
			<p>"selector"代替了手动if判断，是否是自己想要的元素，并将this指回e.target</p>
			<h5>on/off</h5>
			<pre class="code">.on("click",handle)
.on("click","selector",handle)
			</pre>
			<p>on简化了bind和delegate</p>
			<h5>.事件名</h5>
			<pre class="code">.click(handle)</pre>
			<p>bind的简化</p>
			<h4>bind和delegate的区别</h4>
			<p>bind绑定在目标元素身上，而delegate绑定在父元素上，利用了冒泡。</p>
		</div>
	</li>
	<li>
		<p>效果案例</p>
		<div class="desc">
			<h2>效果案例</h2>
			<h3>表单提交</h3>
			<p>当点击提交按钮(input[type=submit])触发事件是表单的提交事件：$("form").submit(function(){})。触发该事件时，判断用户名和密码等是否符合条件，如果不符合，阻止提交e.preventDefault()；</p>
			<h4>判断某元素里是否包含某元素</h4>
			<p>.is()用来判断，参数为条件（选择器）</p>
			<pre class="code">//判断select元素内是否包含当前拿到的option
$("select").is(":has([value="+$(e.target).val()+"])")</pre>
		</div>
	</li>
	<li>
		<p>事件</p>
		<div class="desc">
			<h2>事件</h2>
			<h3>DOMContentLoaded和window.onload</h3>
			<h4>DOMContentLoaded</h4>
			<p>DOM加载完成就触发（html和js），因此操作不需要等待css文件和图片时，首选DOMcontentLoaded</p>
			<p><span class="code">$(document).ready(function(){})</span></p>
			<p><span class="code">简化：$(function(){})</span></p>
			<p><span class="code">ES6中：$(()=>{})</span></p>
			<h4>window.onload</h4>
			<p>待页面所有内容加载完成才执行(html、css、js、图片)，因此，等css和图片加载完成才能执行的操作放在window.onload中</p>
			<h3>鼠标事件</h3>
			<h4>mouseover和mouseout</h4>
			<p>反复进入子元素，会反复触发父元素上的事件。（冒泡）</p>
			<p><strong>解决办法是使用mouseenter和mouseleave</strong>，因为这两事件禁用了冒泡。</p>
			<p>当同时给一个元素绑定mouseenter和mouseleave，可以简化为hover</p>
			<pre class="code">$("#target").hover(function(){
	$(this).toggleClass("hover");//hover中有两个参数，如果两个函数一个，可以合并为一个
});</pre>
			<h3>模拟触发</h3>
			<p>$(...).trigger("click")，也可以简化为$(...).click()</p>

			<h3>笔试题</h3>
			<h4>jQuery中$的原理：4种重载</h4>
			<p>1) 如果传入的是选择器字符串，则查找并创建jQuery对象；</p>
			<p>2) 如果传入DOM 元素对象，则封装现有DOM元素为jQuery对象</p>
			<p>3) 如果传入html代码片段，则创建新元素；</p>
			<p>4) 如果传入函数，则绑定内容加载后执行</p>
			<p>对于选择器字符串，还做了优化（speed up）：①若选择器仅是一个id，则调用getElementById；②标签，则调用getElementsByTagName()；③class，则调用getElementsByClassName()；④复杂选择器，才调用querySelectorAll()</p>

		</div>
	</li>
	<li>
		<p>动画</p>
		<div class="desc">
			<h2>动画</h2>
			<h3>简单动画</h3>
			<table>
				<tr>
					<td rowspan="3">显示和隐藏</td>
					<td>显示</td>
					<td>.show()</td>
					<td>可以带参数ms</td>
				</tr>
				<tr>
					<td>隐藏</td>
					<td>.hide()</td>
					<td>可以带参数ms</td>
				</tr>
				<tr>
					<td>显示/隐藏</td>
					<td>.toggle()</td>
					<td>可以带参数ms</td>
				</tr>
				<tr>
					<td rowspan="3">上滑下滑</td>
					<td>上滑</td>
					<td>.slideUp()</td>
					<td></td>
				</tr>
				<tr>
					<td>下滑</td>
					<td>.slideDown()</td>
					<td></td>
				</tr>
				<tr>
					<td>上滑/下滑</td>
					<td>.slideToggle()</td>
					<td></td>
				</tr>
				<tr>
					<td rowspan="3">淡入淡出</td>
					<td>上滑</td>
					<td>.fadeIn()</td>
					<td></td>
				</tr>
				<tr>
					<td>下滑</td>
					<td>.fadeOut()</td>
					<td></td>
				</tr>
				<tr>
					<td>上滑/下滑</td>
					<td>.fadeToggle()</td>
					<td></td>
				</tr>
			</table>
			<p>如果给出时间参数，则会实现动画效果。但问题是，该动画是用js的定时器实现的动画，效率不如css；另外，该动画效果是固定的，几乎不能更改。</p>
			<h3>万能动画</h3>
			<h4>动画函数</h4>
			<pre class="code">$("#btn1").click(function(){
$("#d1").animate({
	//width:100
	//top:300
	//marginLeft:300
	//opacity:0
	//borderWidth:10
	"font-size":64
},1000);
})</pre>
			<p>注意：只支持单个数值的CSS属性，不支持颜色和CSS3变换。animate也是用定时器实现的。</p>
			<p>判断/选取正在播放动画的元素 <span class="code">:animated</span></p>
			<h4>动画停止和回调</h4>
			<pre class="code">$("#btn1").click(function(){
	var $tar = $("#d1");
	if($tar.is(":animated")){
		$tar.stop();
	}else {
		$tar.animate({
			top:300
		},2000,function(){
			alert("我到终点了");
		})
	}
})</pre>
			<h3>排队和并发</h3>
			<h4>并发：多个CSS属性同时变化</h4>
			<h4>排队：多个CSS属性先后依次执行</h4>
			<p>调用动画API，实际上将动画加入动画列表。</p>
			<p>stop()方法只能停止当前正在执行的动画，而动画列队里的其他动画并没有停止。解决办法是stop(true)，清除动画列队。</p>
			<pre class="code">$(window).load(function(){
	var $msg = $("#msg");
	$msg.animate({bottom:0},1000);

	$msg.find("a").click(function(){
		$msg.animate({bottom:-200},1000),function(){
				$msg.delay(3000).animate({bottom:0},1000)
		}
	});
});</pre>
		</div>
	</li>
	<li>
		<p>类数组对象的API</p>
		<div class="desc">
			<h2>类数组对象API</h2>
			<h3>遍历</h3>
			<pre class="code">$(...).each(function(i,ele){
	<span class="note">//注意：this是当前ele</span>
})


//静态each方法
$.each(数组/集合,callback)</pre>
			<h3>获取索引</h3>
			<pre class="code">var i = $(...).index("要找的DOM元素");
//简化为：
$(子元素).index()</pre>
			<table>
				<tr>
					<td rowspan="2">静态方法</td>
					<td>$.each()</td>
					<td>可遍历数组和类数组对象</td>
				</tr>
				<tr>
					<td>$.inArray()</td>
					<td></td>
				</tr>
				<tr>
					<td rowspan="2">原型方法</td>
					<td>$(..).each()</td>
					<td></td>
				</tr>
				<tr>
					<td>$(..).index()</td>
					<td></td>
				</tr>
			</table>
			<p>另外，获取select标签内选中option的位置，用DOM中属性<span class="code">selectedIndex</span>，而jQuery中，<span class="code">$select.prop("selectedIndex");</span></p>
		</div>
	</li>
	<li>
		<p>jQuery插件</p>
		<div class="desc">
			<h2>jQuery插件</h2>
			<h3>官方插件--jQuery UI</h3>
			<p>首先下载，并引入。引入js文件应该先引入jquery.js</p>
			<h4>效果</h4>
			<p>jQuery UI重写了jQuery中一些API，添加了额外的效果。</p>
			<table>
				<tr>
					<th>#</th>
					<th>特性</th>
				</tr>
				<tr>
					<td>1</td>
					<td>重写了.animate方法，使其支持颜色动画</td>
				</tr>
				<tr>
					<td>2</td>
					<td>为addClass添加了动画效果</td>
				</tr>
				<tr>
					<td>3</td>
					<td>为简单动画添加了更多特效</td>
				</tr>
			</table>
			<h4>部件</h4>
			<p>部件：具有完整的样式和行为的小功能</p>
			<h5>如何使用</h5>
			<p>1) 引入jquery-ui.css</p>
			<p>2) 按照部件约定，编写html内容结构</p>
			<p>3) 引入jquery.js和jquery-ui.js</p>
			<p>4) 在自定义脚本中，找到插件的父元素，调用插件API。该操作时侵入性的，自动添加class和行为，优点是简单，缺点是不可维护。</p>
			<h5>Autocomplete</h5>

			<h3>自定义插件(重点)</h3>
			<p>自定义插件的前提是，已经用普通的HTML、CSS、JS实现了。</p>


			<table>
				<tr>
					<td>jQuery UI的侵入方式</td>
					<td>
						<p>1) 将CSS样式代码提取到外部文件，用link引入</p>
						<p>2) 将js代码提取到外部文件，引入</p>
						<p>3) CSS代码无需修改，重点在于，定义一个该组件的根类名，所有的子元素都在该命名空间下，从而避免影响其他组件的样式</p>
						<p>4) js代码放在jQuery的原型对象中，这样所有jQuery对象都可以调用，实现了代码的复用</p>
					</td>
				</tr>
				<tr>
					<td>bootstrap DIY方式</td>
					<td>
						<p>判断是否提前加载了jquery.js</p>
						<p>在整个页面中查找符合条件的元素，自动绑定事件</p>
					</td>
				</tr>
			</table>
			<h4>jQuery UI的侵入方式</h4>
			<pre class="code"><span class="note">//my_tab.js</span>
if(typeof jQuery !== "function"){
	throw new Error("my-ui依赖于jQuery，请先引入jQuery.js");
}else{
jQuery.fn.tabs = function(){
        //侵入
        $ul = this.children("ul");
        $ul.addClass("tabs")
            .children(":first").addClass("active");
        $ul.find("li>a").attr("data-toggle","tab");
        $ul.next().addClass("container")
            .children(":first").addClass("active");
      	//绑定事件
		this.on("click","[data-toggle=tab]",e=>{
            e.preventDefault();
            var $tar=$(e.target);
            if(!$tar.parent().is(".active")){
                $tar.parent().addClass("active")
                    .siblings().removeClass("active");
            var id=$tar.attr("href");
             $(id).addClass("active")
                    .siblings().removeClass("active");
            }
        })
	}
}</pre>
			<h4>bootstrap DIY方式</h4>
			<pre class="code"><span class="note">my_boot.js</span>
if(typeof jQuery !== "function"){
	throw new Error("my-boot依赖于jQuery，请先引入jQuery.js");
}else{
    <span class="note">//不需要jQuery对象调用API，自动执行</span>
    $(".tabs").on("click","[data-toggle=tab]",e=>{
        e.preventDefault();
        var $tar=$(e.target);
        if(!$tar.parent().is(".active")){
            $tar.parent().addClass("active")
                .siblings().removeClass("active");
        var id=$tar.attr("href");
         $(id).addClass("active")
                .siblings().removeClass("active");
        }
    })
}
			</pre>
			<h3>第三方插件</h3>

			<h4>wysiwyg富文本框</h4>
			<a href="files/wysiwyg.rar" style="text-decoration:underline;color:green;">点击下载</a>

			<h4>masonry</h4>
		</div>
	</li>
	<li>
		<p>ajax</p>
		<div class="desc">
			<h2>jQuery中的ajax API</h2>
			<h3>$.ajax函数</h3>
			<pre class="code">$.ajax({
	url:"getProductById.php",
	type:"get",
	data:"lid="+lid,
	dataType:"json",
	beforeSend:function(xhr){
		console.log("发送请求...")
	},
	complete:function(){
		console.log("请求完成");
	}
	success:function(data){

	},
	error:function(err){
		console.log(err);
	}
)
	</pre>

		</div>
	</li>
	<li>
		<p>跨域请求</p>
		<div class="desc">
			<h2>跨域请求</h2>
			<h3>跨域请求</h3>
			<p>发起请求的域名地址和要请求的目标地址不在同一域名下就是跨域请求。例如自己的应用程序要请求别人网站上的数据(股票信息、天气)。或者，项目太大，前端和后端的应用程序分布在不同的域名下。</p>
			<p>跨域的场景：端口号不同、协议不同、二级域名不同、域名不同、同一主机ip和域名之间互访。</p>
			<p></p>
			<h3>跨域请求的原理</h3>
			<p>虽然ajax中xhr不允许跨域请求，但是诸如img.src、link.href、script.src这些链接属性可以请求跨域的数据。利用这一点可以实现跨域请求数据。</p>
			<h3>jsonp跨域</h3>
			<h4>方式1</h4>
			<p>客户端：不使用xhr，用script标签请求php</p>
			<p>服务端：不只返回数据，而是将数据填充在一段js代码中返回</p>
			<h4>方式2</h4>
			<p>客户端：定义一个接受参数的函数，用script标签的请求php</p>
			<pre class="code">&lt;script src="http://176.16.11.199/jquery/weather.php"&gt;&lt;/script&gt;</pre>
			<p>服务端：</p>
			<pre class="code"><span class="note">//weather.php</span>
$weather = "晴 5-12度";
echo "show('$weather')";</pre>
			<p>该方式问题是函数名必须与服务器端统一</p>
			<h4>方式3</h4>
			<p>客户端：定义一个接收参数的函数，用script请求php，携带一个参数callback，值为函数名</p>
			<pre class="code">&lt;script src="http://176.16.11.199/jquery/weather.php?callback=show"&gt;&lt;/script&gt;</pre>
			<p>服务端</p>
			<pre class="code">$callback = $_REQUEST["callback"];
$weather = "晴 5-12度";
echo "$callback('$weather')";</pre>
			<h4>方式4</h4>
			<p>客户端动态创建script添加到网页，用完自动删除</p>
			<pre class="code">
function show(){
	alert(data);
	$("script:last").remove(); <span class="note">//用完删除</span>
}
$("btnWeather").click(function(){
	$(`&lt;script src='http://176.16.11.199/jquery/weather.php?callback=show'&gt;&lt;\/script&gt;`).appendTo(document.body);
});
			</pre>
			<h3>服务端解决跨域</h3>
			<p>服务器端可以设置允许跨域请求的网址。修改响应头，添加允许跨域的地址</p>
			<pre class="code">header("Access-Control-Allow-Origin:http://127.0.0.1");</pre>
		</div>
	</li>
</ul>